{"ast":null,"code":"function checkIfNeededToAddUndefinedType(obj, objectKey) {\n  const temporaryObject = {};\n  let maxLenghtOfObject = 0;\n  Object.keys(obj).forEach(currentKey => {\n    // check if it's our Object,\n    // like awards.editions in awards.editions.outcome\n    if (currentKey.includes(objectKey) && currentKey !== objectKey) {\n      temporaryObject[currentKey] = obj[currentKey];\n    }\n  }); // We need to check the local maximum\n\n  Object.keys(temporaryObject).forEach(key => {\n    const currentKeyLength = temporaryObject[key].length;\n    if (currentKeyLength > maxLenghtOfObject) maxLenghtOfObject = currentKeyLength;\n  }); // If the maximum is bigger than the current value,\n  // but only one child in, we can also have an undefined.\n\n  Object.keys(temporaryObject).forEach(key => {\n    if (key.split(\".\").length < 2) {\n      if (maxLenghtOfObject > temporaryObject[key].length) {\n        this[key].push(\"undefined\");\n      }\n    }\n  });\n}\n\nfunction keepUniqueTypes(obj, jsonObjects) {\n  const temporaryObject = obj;\n  const remainingObject = {};\n  const numberOfJSONDefinitions = jsonObjects.length;\n  Object.keys(obj).forEach(objectKey => {\n    if (!objectKey.includes(\".\")) {\n      if (obj[objectKey].length < numberOfJSONDefinitions) {\n        temporaryObject[objectKey].push(\"undefined\");\n      }\n    }\n\n    obj[objectKey].forEach(anyValue => {\n      if (anyValue === \"object\" || anyValue === \"object[]\") {\n        checkIfNeededToAddUndefinedType.bind(temporaryObject, obj, objectKey)();\n      }\n    });\n  });\n  Object.keys(temporaryObject).forEach(key => {\n    remainingObject[key] = getUnique(temporaryObject[key]);\n  });\n  return remainingObject;\n}\n/**\n * @param {Array} array - The array that needs to be ded-duplicated\n * @returns {Array}\n */\n\n\nfunction getUnique(array) {\n  const u = {};\n  const a = [];\n\n  for (let i = 0, l = array.length; i < l; ++i) {\n    if (u.hasOwnProperty(array[i])) continue;\n    a.push(array[i]);\n    u[array[i]] = 1;\n  }\n\n  return a;\n}\n/**\n * @param {*} value\n * @returns {string} currentType - lowerCased type of value\n */\n\n\nfunction getTypeOfValue(value) {\n  let currentType = Object.prototype.toString.call(value).split(\" \")[1].slice(0, -1).toLowerCase();\n  if (!currentType) currentType = \"*\";\n  return currentType;\n}\n/**\n * @param {Array} array - The array that we want to parse\n * @param {string} objectName - Usually the Prefix - Root do no have ObjectName\n */\n\n\nfunction parseArray(array, objectName) {\n  const currentArrayTypes = [];\n  const prefix = objectName ? `${objectName}` : \"\";\n  array.forEach(currentValue => {\n    currentArrayTypes.push(`${getTypeOfValue(currentValue)}[]`);\n  });\n  if (!(objectName in this)) this[objectName] = [];\n  this[objectName].push(getUnique(currentArrayTypes).join(\"|\"));\n  array.forEach(currentValue => {\n    const currentValueType = getTypeOfValue(currentValue);\n\n    if (currentValueType === \"array\") {\n      parseArray.bind(this, currentValue, prefix)();\n    } else if (currentValueType === \"object\") {\n      parseObject.bind(this, currentValue, prefix, true)();\n    }\n  });\n}\n/**\n * @param {object} obj - The object that we want to parse\n * @param {string} objectName - Usually the Prefix - Root do no have ObjectName\n * @param {boolean} doNotReinsert - If we want to reinsert the type, usually when we parse\n * an array of objects, we do not want to reinsert.\n */\n\n\nfunction parseObject(obj, objectName, doNotReinsert = false) {\n  const prefix = objectName ? `${objectName}.` : \"\";\n  Object.keys(obj).forEach(propertyName => {\n    const currentValue = obj[propertyName];\n    const propertyType = getTypeOfValue(currentValue);\n    const currentPrefix = `${prefix}${propertyName}`;\n    let result = null; // Root Object don't have a objectName\n\n    if (!doNotReinsert && objectName) {\n      if (!(objectName in this)) this[objectName] = [];\n      this[objectName].push(\"object\");\n    } // If it's Array, we need the values inside.\n\n\n    if (propertyType === \"array\") parseArray.bind(this, currentValue, currentPrefix)();else if (propertyType === \"object\") parseObject.bind(this, currentValue, currentPrefix)();else {\n      result = propertyType;\n      if (!(currentPrefix in this)) this[currentPrefix] = [];\n      this[currentPrefix].push(result);\n    }\n  });\n}\n\nfunction ParseRootDefinition(obj) {\n  // 1. What is the default type for our Definition?\n  const jsonType = typeof obj;\n  if (jsonType === \"array\") parseArray.bind(this, obj)();else if (jsonType === \"object\") parseObject.bind(this, obj)();\n}\n/**\n * @param {Object} obj\n * @param {Object[]} jsonObjects\n */\n\n\nfunction printTheTypeDef(obj, jsonObjects) {\n  let output = \"\"; // 0. A default name for our Definition\n\n  const jsonDef = \"json\";\n  const jsonTypes = [];\n  Object.keys(jsonObjects).forEach(key => {\n    jsonTypes.push(getTypeOfValue(jsonObjects[key]));\n  });\n  output = `/** @typedef {${getUnique(jsonTypes)}} ${jsonDef} \\n`;\n  Object.keys(obj).forEach(key => {\n    output += `* @property {${obj[key].join(\"|\")}} ${key} \\n`;\n  });\n  output += \"*/\";\n  return output;\n}\n/**\n * @param {Array} jsonObjects\n */\n\n\nfunction goThroughAndParse(jsonObjects) {\n  const theObjectDefinition = {};\n  jsonObjects.forEach(obj => ParseRootDefinition.bind(theObjectDefinition, obj)());\n  return printTheTypeDef(keepUniqueTypes(theObjectDefinition, jsonObjects), jsonObjects);\n}\n\nexport function convert(json) {\n  const jsonObjects = [];\n  jsonObjects.push(JSON.parse(json));\n  return goThroughAndParse(jsonObjects);\n}","map":null,"metadata":{},"sourceType":"module"}