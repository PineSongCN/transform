{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport ConversionPanel from \"@components/ConversionPanel\";\nimport * as React from \"react\";\nimport { useCallback } from \"react\";\nexport default function JsonToJava() {\n  const transformer = useCallback(async ({\n    value\n  }) => {\n    const {\n      run\n    } = await import(\"json_typegen_wasm\");\n    const kotlinTransformationLines = run(\"Root\", value, JSON.stringify({\n      output_mode: \"kotlin\"\n    })).split(\"\\n\"); // use Kotlin transformation to convert JSON to Java\n\n    let javaTransformation = \"\";\n    let currentClass = \"\";\n    let variableNames = [];\n    let variableTypes = [];\n    kotlinTransformationLines.forEach(line => {\n      const originalLine = line;\n      line = line.trim();\n\n      if (line === \")\") {\n        // Class is closing so generate constructor, getters and setters for\n        // the current class, close the class and reset running values\n        let args = [];\n        let getters = [];\n        let setters = []; // Create args for constructor, getters and setters\n\n        for (let i = 0; i < variableNames.length; i++) {\n          const type = variableTypes[i];\n          const variableName = variableNames[i];\n          const titleCaseVariable = variableName.charAt(0).toUpperCase() + variableName.substring(1);\n          args.push(`${type} ${variableName}`);\n          getters.push(`\\tpublic ${type} get${titleCaseVariable}() {\\n\\t\\treturn this.${variableName};\\n\\t}\\n`);\n          setters.push(`\\tpublic void set${titleCaseVariable}(${type} ${variableName}) {\\n\\t\\tthis.${variableName} = ${variableName};\\n\\t}\\n`);\n        } // Create constructor\n\n\n        let constructor = `\\tpublic ${currentClass}(${args.join(\", \")}) {`;\n        let properties = [];\n        variableNames.forEach(variable => {\n          properties.push(`this.${variable} = ${variable};`);\n        });\n        constructor += `\\n\\t\\t${properties.join(\"\\n\\t\\t\")}\\n\\t}\\n`;\n        javaTransformation += `\\n${constructor}\\n${getters.join(\"\\n\")}\\n${setters.join(\"\\n\")}}`; // Reset running values\n\n        currentClass = \"\";\n        variableNames = [];\n        variableTypes = [];\n      } else if (line.startsWith(\"data class \")) {\n        // Change the start of a class from 'data class Root(' to 'public class Root {'\n        const classNameStartIndex = 11;\n        const classNameEndIndex = line.indexOf(\"(\");\n        const className = line.substring(classNameStartIndex, classNameEndIndex);\n        javaTransformation += `public class ${className} {`;\n        currentClass = className;\n      } else if (line.startsWith(\"val\")) {\n        // If this is a variable, change 'val name: String' to 'private String name;'\n        // followed by respective getters, setters for the variable\n        const processedLine = line.replace(\"?\", \"\");\n        const variableStartIndex = 4; // length of string \"val \"\n\n        const variableEndIndex = processedLine.indexOf(\":\");\n        const variable = processedLine.substring(variableStartIndex, variableEndIndex);\n        const typeStartIndex = processedLine.indexOf(\":\") + 2;\n        let type = processedLine.substring(typeStartIndex, processedLine.length - 1); // Update kotlin generic typing to Java generic typing\n\n        type = type.replace(\"<Any>?\", \"<?>\");\n        type = type.replace(\"<Any>\", \"<?>\"); // Save variables and their types to be later used in constructor, getter, setter generation\n\n        variableNames.push(variable);\n        variableTypes.push(type);\n        javaTransformation += `\\tprivate ${type} ${variable};`;\n      } else if (line.startsWith(\"typealias\")) {\n        // If this is a kotlin typealias, make it into a class\n        const classNameStartIndex = 10; // length of string \"typealias \"\n\n        const classNameEndIndex = line.indexOf(\" =\");\n        const className = line.substring(classNameStartIndex, classNameEndIndex);\n        const typeNameEndIndex = line.indexOf(\"=\") + 2;\n        const type = line.substring(typeNameEndIndex, line.length - 1); // ignore the semi-colon\n\n        const variable = className.charAt(0).toLowerCase() + className.substring(1);\n        const titleCaseVariable = className;\n        const getters = `\\tpublic ${type} get${titleCaseVariable}() {\\n\\t\\treturn this.${variable};\\n\\t}\\n\\n`;\n        const setters = `\\tpublic void set${titleCaseVariable}(${type} ${variable}) {\\n\\t\\tthis.${variable} = ${variable};\\n\\t}\\n\\n`;\n        const constructor = `\\tpublic ${className}(${type} ${variable}) {\\n\\t\\tthis.${variable} = ${variable};\\n\\t}\\n`;\n        javaTransformation += `public class ${className} {\\n\\tprivate ${type} ${variable};\\n`;\n        javaTransformation += `\\n${constructor}\\n${getters}${setters}}`;\n      } else if (line.startsWith(\"import\")) {\n        javaTransformation += `${line};`;\n      } else {\n        // If there's any other line, it is most probably a 'next line character', so just append it\n        javaTransformation += originalLine;\n      }\n\n      javaTransformation += \"\\n\";\n    });\n    return javaTransformation;\n  }, []);\n  return /*#__PURE__*/_jsx(ConversionPanel, {\n    transformer: transformer,\n    editorTitle: \"JSON\",\n    editorLanguage: \"json\",\n    resultTitle: \"Java\",\n    resultLanguage: \"java\"\n  });\n}","map":null,"metadata":{},"sourceType":"module"}