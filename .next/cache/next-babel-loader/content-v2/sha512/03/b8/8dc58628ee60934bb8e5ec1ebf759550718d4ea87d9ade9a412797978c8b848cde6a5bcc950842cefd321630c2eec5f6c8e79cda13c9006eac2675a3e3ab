{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst resolves = {};\nconst rejects = {};\nlet globalMsgId = 0; // Activate calculation in the worker, returning a promise\n\nfunction sendMsg(payload, worker) {\n  const msgId = globalMsgId++;\n  const msg = {\n    id: msgId,\n    payload\n  };\n  return new Promise(function (resolve, reject) {\n    // save callbacks for later\n    resolves[msgId] = resolve;\n    rejects[msgId] = reject;\n    worker.postMessage(msg); // TODO: CHECK FOR MEMORY LEAK\n  });\n} // Handle incoming calculation result\n\n\nfunction handleMsg(msg) {\n  const {\n    id,\n    err,\n    payload\n  } = msg.data;\n\n  if (payload) {\n    const resolve = resolves[id];\n\n    if (resolve) {\n      resolve(payload);\n    }\n  } else {\n    // error condition\n    const reject = rejects[id];\n\n    if (reject) {\n      if (err) {\n        reject(new Error(err));\n      } else {\n        reject(\"Got nothing\");\n      }\n    }\n  } // purge used callbacks\n\n\n  delete resolves[id];\n  delete rejects[id];\n}\n\nexport class Wrapper {\n  constructor(worker) {\n    _defineProperty(this, \"worker\", void 0);\n\n    this.worker = worker;\n    this.worker.onmessage = handleMsg;\n  }\n\n  send(str) {\n    return sendMsg(str, this.worker);\n  }\n\n}\nexport function getWorker(Worker) {\n  return new Wrapper(new Worker());\n}","map":null,"metadata":{},"sourceType":"module"}