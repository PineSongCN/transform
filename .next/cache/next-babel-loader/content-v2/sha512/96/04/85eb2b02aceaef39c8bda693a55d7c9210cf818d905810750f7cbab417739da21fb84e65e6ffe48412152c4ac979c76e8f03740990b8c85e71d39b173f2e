{"ast":null,"code":"function checkIfNeededToAddUndefinedType(obj, objectKey) {\n  var _this = this;\n\n  var temporaryObject = {};\n  var maxLenghtOfObject = 0;\n  Object.keys(obj).forEach(function (currentKey) {\n    // check if it's our Object,\n    // like awards.editions in awards.editions.outcome\n    if (currentKey.includes(objectKey) && currentKey !== objectKey) {\n      temporaryObject[currentKey] = obj[currentKey];\n    }\n  }); // We need to check the local maximum\n\n  Object.keys(temporaryObject).forEach(function (key) {\n    var currentKeyLength = temporaryObject[key].length;\n    if (currentKeyLength > maxLenghtOfObject) maxLenghtOfObject = currentKeyLength;\n  }); // If the maximum is bigger than the current value,\n  // but only one child in, we can also have an undefined.\n\n  Object.keys(temporaryObject).forEach(function (key) {\n    if (key.split(\".\").length < 2) {\n      if (maxLenghtOfObject > temporaryObject[key].length) {\n        _this[key].push(\"undefined\");\n      }\n    }\n  });\n}\n\nfunction keepUniqueTypes(obj, jsonObjects) {\n  var temporaryObject = obj;\n  var remainingObject = {};\n  var numberOfJSONDefinitions = jsonObjects.length;\n  Object.keys(obj).forEach(function (objectKey) {\n    if (!objectKey.includes(\".\")) {\n      if (obj[objectKey].length < numberOfJSONDefinitions) {\n        temporaryObject[objectKey].push(\"undefined\");\n      }\n    }\n\n    obj[objectKey].forEach(function (anyValue) {\n      if (anyValue === \"object\" || anyValue === \"object[]\") {\n        checkIfNeededToAddUndefinedType.bind(temporaryObject, obj, objectKey)();\n      }\n    });\n  });\n  Object.keys(temporaryObject).forEach(function (key) {\n    remainingObject[key] = getUnique(temporaryObject[key]);\n  });\n  return remainingObject;\n}\n/**\n * @param {Array} array - The array that needs to be ded-duplicated\n * @returns {Array}\n */\n\n\nfunction getUnique(array) {\n  var u = {};\n  var a = [];\n\n  for (var i = 0, l = array.length; i < l; ++i) {\n    if (u.hasOwnProperty(array[i])) continue;\n    a.push(array[i]);\n    u[array[i]] = 1;\n  }\n\n  return a;\n}\n/**\n * @param {*} value\n * @returns {string} currentType - lowerCased type of value\n */\n\n\nfunction getTypeOfValue(value) {\n  var currentType = Object.prototype.toString.call(value).split(\" \")[1].slice(0, -1).toLowerCase();\n  if (!currentType) currentType = \"*\";\n  return currentType;\n}\n/**\n * @param {Array} array - The array that we want to parse\n * @param {string} objectName - Usually the Prefix - Root do no have ObjectName\n */\n\n\nfunction parseArray(array, objectName) {\n  var _this2 = this;\n\n  var currentArrayTypes = [];\n  var prefix = objectName ? \"\".concat(objectName) : \"\";\n  array.forEach(function (currentValue) {\n    currentArrayTypes.push(\"\".concat(getTypeOfValue(currentValue), \"[]\"));\n  });\n  if (!(objectName in this)) this[objectName] = [];\n  this[objectName].push(getUnique(currentArrayTypes).join(\"|\"));\n  array.forEach(function (currentValue) {\n    var currentValueType = getTypeOfValue(currentValue);\n\n    if (currentValueType === \"array\") {\n      parseArray.bind(_this2, currentValue, prefix)();\n    } else if (currentValueType === \"object\") {\n      parseObject.bind(_this2, currentValue, prefix, true)();\n    }\n  });\n}\n/**\n * @param {object} obj - The object that we want to parse\n * @param {string} objectName - Usually the Prefix - Root do no have ObjectName\n * @param {boolean} doNotReinsert - If we want to reinsert the type, usually when we parse\n * an array of objects, we do not want to reinsert.\n */\n\n\nfunction parseObject(obj, objectName) {\n  var _this3 = this;\n\n  var doNotReinsert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var prefix = objectName ? \"\".concat(objectName, \".\") : \"\";\n  Object.keys(obj).forEach(function (propertyName) {\n    var currentValue = obj[propertyName];\n    var propertyType = getTypeOfValue(currentValue);\n    var currentPrefix = \"\".concat(prefix).concat(propertyName);\n    var result = null; // Root Object don't have a objectName\n\n    if (!doNotReinsert && objectName) {\n      if (!(objectName in _this3)) _this3[objectName] = [];\n\n      _this3[objectName].push(\"object\");\n    } // If it's Array, we need the values inside.\n\n\n    if (propertyType === \"array\") parseArray.bind(_this3, currentValue, currentPrefix)();else if (propertyType === \"object\") parseObject.bind(_this3, currentValue, currentPrefix)();else {\n      result = propertyType;\n      if (!(currentPrefix in _this3)) _this3[currentPrefix] = [];\n\n      _this3[currentPrefix].push(result);\n    }\n  });\n}\n\nfunction ParseRootDefinition(obj) {\n  // 1. What is the default type for our Definition?\n  var jsonType = typeof obj;\n  if (jsonType === \"array\") parseArray.bind(this, obj)();else if (jsonType === \"object\") parseObject.bind(this, obj)();\n}\n/**\n * @param {Object} obj\n * @param {Object[]} jsonObjects\n */\n\n\nfunction printTheTypeDef(obj, jsonObjects) {\n  var output = \"\"; // 0. A default name for our Definition\n\n  var jsonDef = \"json\";\n  var jsonTypes = [];\n  Object.keys(jsonObjects).forEach(function (key) {\n    jsonTypes.push(getTypeOfValue(jsonObjects[key]));\n  });\n  output = \"/** @typedef {\".concat(getUnique(jsonTypes), \"} \").concat(jsonDef, \" \\n\");\n  Object.keys(obj).forEach(function (key) {\n    output += \"* @property {\".concat(obj[key].join(\"|\"), \"} \").concat(key, \" \\n\");\n  });\n  output += \"*/\";\n  return output;\n}\n/**\n * @param {Array} jsonObjects\n */\n\n\nfunction goThroughAndParse(jsonObjects) {\n  var theObjectDefinition = {};\n  jsonObjects.forEach(function (obj) {\n    return ParseRootDefinition.bind(theObjectDefinition, obj)();\n  });\n  return printTheTypeDef(keepUniqueTypes(theObjectDefinition, jsonObjects), jsonObjects);\n}\n\nexport function convert(json) {\n  var jsonObjects = [];\n  jsonObjects.push(JSON.parse(json));\n  return goThroughAndParse(jsonObjects);\n}","map":null,"metadata":{},"sourceType":"module"}