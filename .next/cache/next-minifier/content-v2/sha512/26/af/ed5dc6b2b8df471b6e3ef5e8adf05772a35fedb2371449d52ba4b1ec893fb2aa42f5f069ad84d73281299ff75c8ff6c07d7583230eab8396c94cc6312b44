{"code":"_N_E=(\"object\"!==typeof self?self:this.webpackJsonp_N_E=\"object\"!==typeof self?self:this.webpackJsonp_N_E||[]).push([[81],{\"4g3d\":function(e,t,n){\"use strict\";n.r(t),n.d(t,\"default\",(function(){return a}));var r=n(\"nKUr\"),i=n(\"sN8P\"),l=n(\"q1tI\"),s=n(\"jdwX\");function a(){var e=Object(l.useCallback)((function(e){var t=e.value;return s.markdown.toHTML(t)}),[]);return Object(r.jsx)(i.a,{transformer:e,editorTitle:\"Markdown\",editorLanguage:\"markdown\",resultTitle:\"HTML\",resultLanguage:\"html\",resultEditorProps:{previewElement:function(e){return Object(r.jsx)(\"div\",{dangerouslySetInnerHTML:{__html:e}})}}})}},\"8oxB\":function(e,t){var n,r,i=e.exports={};function l(){throw new Error(\"setTimeout has not been defined\")}function s(){throw new Error(\"clearTimeout has not been defined\")}function a(e){if(n===setTimeout)return setTimeout(e,0);if((n===l||!n)&&setTimeout)return n=setTimeout,setTimeout(e,0);try{return n(e,0)}catch(t){try{return n.call(null,e,0)}catch(t){return n.call(this,e,0)}}}!function(){try{n=\"function\"===typeof setTimeout?setTimeout:l}catch(e){n=l}try{r=\"function\"===typeof clearTimeout?clearTimeout:s}catch(e){r=s}}();var o,c=[],u=!1,h=-1;function f(){u&&o&&(u=!1,o.length?c=o.concat(c):h=-1,c.length&&p())}function p(){if(!u){var e=a(f);u=!0;for(var t=c.length;t;){for(o=c,c=[];++h<t;)o&&o[h].run();h=-1,t=c.length}o=null,u=!1,function(e){if(r===clearTimeout)return clearTimeout(e);if((r===s||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(e);try{r(e)}catch(t){try{return r.call(null,e)}catch(t){return r.call(this,e)}}}(e)}}function g(e,t){this.fun=e,this.array=t}function d(){}i.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];c.push(new g(e,t)),1!==c.length||u||a(p)},g.prototype.run=function(){this.fun.apply(null,this.array)},i.title=\"browser\",i.browser=!0,i.env={},i.argv=[],i.version=\"\",i.versions={},i.on=d,i.addListener=d,i.once=d,i.off=d,i.removeListener=d,i.removeAllListeners=d,i.emit=d,i.prependListener=d,i.prependOnceListener=d,i.listeners=function(e){return[]},i.binding=function(e){throw new Error(\"process.binding is not supported\")},i.cwd=function(){return\"/\"},i.chdir=function(e){throw new Error(\"process.chdir is not supported\")},i.umask=function(){return 0}},jLCa:function(e,t,n){!function(e){var t=e.Markdown=function(e){switch(typeof e){case\"undefined\":this.dialect=t.dialects.Gruber;break;case\"object\":this.dialect=e;break;default:if(!(e in t.dialects))throw new Error(\"Unknown Markdown dialect '\"+String(e)+\"'\");this.dialect=t.dialects[e]}this.em_state=[],this.strong_state=[],this.debug_indent=\"\"};function r(){return\"Markdown.mk_block( \"+uneval(this.toString())+\", \"+uneval(this.trailing)+\", \"+uneval(this.lineNumber)+\" )\"}function i(){var e=n(\"7tlc\");return\"Markdown.mk_block( \"+e.inspect(this.toString())+\", \"+e.inspect(this.trailing)+\", \"+e.inspect(this.lineNumber)+\" )\"}e.parse=function(e,n){return new t(n).toTree(e)},e.toHTML=function(t,n,r){var i=e.toHTMLTree(t,n,r);return e.renderJsonML(i)},e.toHTMLTree=function(e,t,n){\"string\"===typeof e&&(e=this.parse(e,t));var r=f(e),i={};r&&r.references&&(i=r.references);var l=v(e,i,n);return _(l),l};var l=t.mk_block=function(e,t,n){1==arguments.length&&(t=\"\\n\\n\");var l=new String(e);return l.trailing=t,l.inspect=i,l.toSource=r,void 0!=n&&(l.lineNumber=n),l};function s(e){for(var t=0,n=-1;-1!==(n=e.indexOf(\"\\n\",n+1));)t++;return t}function o(e,t){var n=e+\"_state\",r=\"strong\"==e?\"em_state\":\"strong_state\";function i(e){this.len_after=e,this.name=\"close_\"+t}return function(l,s){if(this[n][0]==t)return this[n].shift(),[l.length,new i(l.length-t.length)];var a=this[r].slice(),o=this[n].slice();this[n].unshift(t);var c=this.processInline(l.substr(t.length)),u=c[c.length-1];this[n].shift();return u instanceof i?(c.pop(),[l.length-u.len_after,[e].concat(c)]):(this[r]=a,this[n]=o,[t.length,t])}}t.prototype.split_blocks=function(e,t){e=e.replace(/(\\r\\n|\\n|\\r)/g,\"\\n\");var n,r=/([\\s\\S]+?)($|\\n#|\\n(?:\\s*\\n|$)+)/g,i=[],a=1;for(null!=(n=/^(\\s*\\n)/.exec(e))&&(a+=s(n[0]),r.lastIndex=n[0].length);null!==(n=r.exec(e));)\"\\n#\"==n[2]&&(n[2]=\"\\n\",r.lastIndex--),i.push(l(n[1],n[2],a)),a+=s(n[0]);return i},t.prototype.processBlock=function(e,t){var n=this.dialect.block,r=n.__order__;if(\"__call__\"in n)return n.__call__.call(this,e,t);for(var i=0;i<r.length;i++){var l=n[r[i]].call(this,e,t);if(l)return(!u(l)||l.length>0&&!u(l[0]))&&this.debug(r[i],\"didn't return a proper array\"),l}return[]},t.prototype.processInline=function(e){return this.dialect.inline.__call__.call(this,String(e))},t.prototype.toTree=function(e,t){var n=e instanceof Array?e:this.split_blocks(e),r=this.tree;try{for(this.tree=t||this.tree||[\"markdown\"];n.length;){var i=this.processBlock(n.shift(),n);i.length&&this.tree.push.apply(this.tree,i)}return this.tree}finally{t&&(this.tree=r)}},t.prototype.debug=function(){var e=Array.prototype.slice.call(arguments);e.unshift(this.debug_indent),\"undefined\"!==typeof print&&print.apply(print,e),\"undefined\"!==typeof console&&\"undefined\"!==typeof console.log&&console.log.apply(null,e)},t.prototype.loop_re_over_block=function(e,t,n){for(var r,i=t.valueOf();i.length&&null!=(r=e.exec(i));)i=i.substr(r[0].length),n.call(this,r);return i},t.dialects={},t.dialects.Gruber={block:{atxHeader:function(e,t){var n=e.match(/^(#{1,6})\\s*(.*?)\\s*#*\\s*(?:\\n|$)/);if(n){var r=[\"header\",{level:n[1].length}];return Array.prototype.push.apply(r,this.processInline(n[2])),n[0].length<e.length&&t.unshift(l(e.substr(n[0].length),e.trailing,e.lineNumber+2)),[r]}},setextHeader:function(e,t){var n=e.match(/^(.*)\\n([-=])\\2\\2+(?:\\n|$)/);if(n){var r=[\"header\",{level:\"=\"===n[2]?1:2},n[1]];return n[0].length<e.length&&t.unshift(l(e.substr(n[0].length),e.trailing,e.lineNumber+2)),[r]}},code:function(e,t){var n=[],r=/^(?: {0,3}\\t| {4})(.*)\\n?/;if(e.match(r)){e:for(;;){var i=this.loop_re_over_block(r,e.valueOf(),(function(e){n.push(e[1])}));if(i.length){t.unshift(l(i,e.trailing));break e}if(!t.length)break e;if(!t[0].match(r))break e;n.push(e.trailing.replace(/[^\\n]/g,\"\").substring(2)),e=t.shift()}return[[\"code_block\",n.join(\"\\n\")]]}},horizRule:function(e,t){var n=e.match(/^(?:([\\s\\S]*?)\\n)?[ \\t]*([-_*])(?:[ \\t]*\\2){2,}[ \\t]*(?:\\n([\\s\\S]*))?$/);if(n){var r=[[\"hr\"]];return n[1]&&r.unshift.apply(r,this.processBlock(n[1],[])),n[3]&&t.unshift(l(n[3])),r}},lists:function(){var e=\"[*+-]|\\\\d+\\\\.\",t=/[*+-]/,n=new RegExp(\"^( {0,3})([*+-]|\\\\d+\\\\.)[ \\t]+\"),r=\"(?: {0,3}\\\\t| {4})\";function i(e,t,n,r){if(t)e.push([\"para\"].concat(n));else{var i=e[e.length-1]instanceof Array&&\"para\"==e[e.length-1][0]?e[e.length-1]:e;r&&e.length>1&&n.unshift(r);for(var l=0;l<n.length;l++){var s=n[l];\"string\"==typeof s&&i.length>1&&\"string\"==typeof i[i.length-1]?i[i.length-1]+=s:i.push(s)}}}function s(e,t){for(var n=new RegExp(\"^(\"+r+\"{\"+e+\"}.*?\\\\n?)*$\"),i=new RegExp(\"^\"+r+\"{\"+e+\"}\",\"gm\"),s=[];t.length>0&&n.exec(t[0]);){var a=t.shift(),o=a.replace(i,\"\");s.push(l(o,a.trailing,a.lineNumber))}return s}function a(e,t,n){var r=e.list,i=r[r.length-1];if(!(i[1]instanceof Array&&\"para\"==i[1][0]))if(t+1==n.length)i.push([\"para\"].concat(i.splice(1,i.length-1)));else{var l=i.pop();i.push([\"para\"].concat(i.splice(1,i.length-1)),l)}}return function(l,o){var u=l.match(n);if(u){for(var h,f,p,g=[],d=L(u),v=!1,_=[g[0].list];;){for(var b=l.split(/(?=\\n)/),m=\"\",k=0;k<b.length;k++){var y=\"\",w=b[k].replace(/^\\n/,(function(e){return y=e,\"\"})),T=(p=g.length,new RegExp(\"(?:^(\"+r+\"{0,\"+p+\"} {0,3})(\"+e+\")\\\\s+)|(^\"+r+\"{0,\"+(p-1)+\"}[ ]{0,4})\"));if(void 0!==(u=w.match(T))[1]){m.length&&(i(h,v,this.processInline(m),y),v=!1,m=\"\"),u[1]=u[1].replace(/ {0,3}\\t/g,\"    \");var M=Math.floor(u[1].length/4)+1;if(M>g.length)d=L(u),h.push(d),h=d[1]=[\"listitem\"];else{var $=!1;for(f=0;f<g.length;f++)if(g[f].indent==u[1]){d=g[f].list,g.splice(f+1,g.length-(f+1)),$=!0;break}$||(++M<=g.length?(g.splice(M,g.length-M),d=g[M-1].list):(d=L(u),h.push(d))),h=[\"listitem\"],d.push(h)}y=\"\"}w.length>u[0].length&&(m+=y+w.substr(u[0].length))}m.length&&(i(h,v,this.processInline(m),y),v=!1,m=\"\");var x=s(g.length,o);x.length>0&&(c(g,a,this),h.push.apply(h,this.toTree(x,[])));var j=o[0]&&o[0].valueOf()||\"\";if(!j.match(n)&&!j.match(/^ /))break;l=o.shift();var E=this.dialect.block.horizRule(l,o);if(E){_.push.apply(_,E);break}c(g,a,this),v=!0}return _}function L(e){var n=t.exec(e[2])?[\"bulletlist\"]:[\"numberlist\"];return g.push({list:n,indent:e[1]}),n}}}(),blockquote:function(e,t){if(e.match(/^>/m)){var n=[];if(\">\"!=e[0]){for(var r=e.split(/\\n/),i=[],s=e.lineNumber;r.length&&\">\"!=r[0][0];)i.push(r.shift()),s++;var a=l(i.join(\"\\n\"),\"\\n\",e.lineNumber);n.push.apply(n,this.processBlock(a,[])),e=l(r.join(\"\\n\"),e.trailing,s)}for(;t.length&&\">\"==t[0][0];){var o=t.shift();e=l(e+e.trailing+o,o.trailing,e.lineNumber)}var c=e.replace(/^> ?/gm,\"\"),u=(this.tree,this.toTree(c,[\"blockquote\"])),p=f(u);return p&&p.references&&(delete p.references,h(p)&&u.splice(1,1)),n.push(u),n}},referenceDefn:function(e,t){var n=/^\\s*\\[(.*?)\\]:\\s*(\\S+)(?:\\s+(?:(['\"])(.*?)\\3|\\((.*?)\\)))?\\n?/;if(e.match(n)){f(this.tree)||this.tree.splice(1,0,{});var r=f(this.tree);void 0===r.references&&(r.references={});var i=this.loop_re_over_block(n,e,(function(e){e[2]&&\"<\"==e[2][0]&&\">\"==e[2][e[2].length-1]&&(e[2]=e[2].substring(1,e[2].length-1));var t=r.references[e[1].toLowerCase()]={href:e[2]};void 0!==e[4]?t.title=e[4]:void 0!==e[5]&&(t.title=e[5])}));return i.length&&t.unshift(l(i,e.trailing)),[]}},para:function(e,t){return[[\"para\"].concat(this.processInline(e))]}}},t.dialects.Gruber.inline={__oneElement__:function(e,t,n){var r,i;return t=t||this.dialect.inline.__patterns__,(r=new RegExp(\"([\\\\s\\\\S]*?)(\"+(t.source||t)+\")\").exec(e))?r[1]?[r[1].length,r[1]]:(r[2]in this.dialect.inline&&(i=this.dialect.inline[r[2]].call(this,e.substr(r.index),r,n||[])),i=i||[r[2].length,r[2]]):[e.length,e]},__call__:function(e,t){var n,r=[];function i(e){\"string\"==typeof e&&\"string\"==typeof r[r.length-1]?r[r.length-1]+=e:r.push(e)}for(;e.length>0;)n=this.dialect.inline.__oneElement__.call(this,e,t,r),e=e.substr(n.shift()),c(n,i);return r},\"]\":function(){},\"}\":function(){},__escape__:/^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-]/,\"\\\\\":function(e){return this.dialect.inline.__escape__.exec(e)?[2,e.charAt(1)]:[1,\"\\\\\"]},\"![\":function(e){var t=e.match(/^!\\[(.*?)\\][ \\t]*\\([ \\t]*([^\")]*?)(?:[ \\t]+([\"'])(.*?)\\3)?[ \\t]*\\)/);if(t){t[2]&&\"<\"==t[2][0]&&\">\"==t[2][t[2].length-1]&&(t[2]=t[2].substring(1,t[2].length-1)),t[2]=this.dialect.inline.__call__.call(this,t[2],/\\\\/)[0];var n={alt:t[1],href:t[2]||\"\"};return void 0!==t[4]&&(n.title=t[4]),[t[0].length,[\"img\",n]]}return(t=e.match(/^!\\[(.*?)\\][ \\t]*\\[(.*?)\\]/))?[t[0].length,[\"img_ref\",{alt:t[1],ref:t[2].toLowerCase(),original:t[0]}]]:[2,\"![\"]},\"[\":function(e){var n=String(e),r=t.DialectHelpers.inline_until_char.call(this,e.substr(1),\"]\");if(!r)return[1,\"[\"];var i,l,s=1+r[0],a=r[1],o=(e=e.substr(s)).match(/^\\s*\\([ \\t]*([^\"']*)(?:[ \\t]+([\"'])(.*?)\\2)?[ \\t]*\\)/);if(o){var c=o[1];if(s+=o[0].length,c&&\"<\"==c[0]&&\">\"==c[c.length-1]&&(c=c.substring(1,c.length-1)),!o[3])for(var u=1,h=0;h<c.length;h++)switch(c[h]){case\"(\":u++;break;case\")\":0==--u&&(s-=c.length-h,c=c.substring(0,h))}return l={href:(c=this.dialect.inline.__call__.call(this,c,/\\\\/)[0])||\"\"},void 0!==o[3]&&(l.title=o[3]),i=[\"link\",l].concat(a),[s,i]}return(o=e.match(/^\\s*\\[(.*?)\\]/))?(s+=o[0].length,i=[\"link_ref\",l={ref:(o[1]||String(a)).toLowerCase(),original:n.substr(0,s)}].concat(a),[s,i]):1==a.length&&\"string\"==typeof a[0]?(i=[\"link_ref\",l={ref:a[0].toLowerCase(),original:n.substr(0,s)},a[0]],[s,i]):[1,\"[\"]},\"<\":function(e){var t;return null!=(t=e.match(/^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\\.[a-zA-Z]+))>/))?t[3]?[t[0].length,[\"link\",{href:\"mailto:\"+t[3]},t[3]]]:\"mailto\"==t[2]?[t[0].length,[\"link\",{href:t[1]},t[1].substr(\"mailto:\".length)]]:[t[0].length,[\"link\",{href:t[1]},t[1]]]:[1,\"<\"]},\"`\":function(e){var t=e.match(/(`+)(([\\s\\S]*?)\\1)/);return t&&t[2]?[t[1].length+t[2].length,[\"inlinecode\",t[3]]]:[1,\"`\"]},\"  \\n\":function(e){return[3,[\"linebreak\"]]}},t.dialects.Gruber.inline[\"**\"]=o(\"strong\",\"**\"),t.dialects.Gruber.inline.__=o(\"strong\",\"__\"),t.dialects.Gruber.inline[\"*\"]=o(\"em\",\"*\"),t.dialects.Gruber.inline._=o(\"em\",\"_\"),t.buildBlockOrder=function(e){var t=[];for(var n in e)\"__order__\"!=n&&\"__call__\"!=n&&t.push(n);e.__order__=t},t.buildInlinePatterns=function(e){var t=[];for(var n in e)if(!n.match(/^__.*__$/)){var r=n.replace(/([\\\\.*+?|()\\[\\]{}])/g,\"\\\\$1\").replace(/\\n/,\"\\\\n\");t.push(1==n.length?r:\"(?:\"+r+\")\")}t=t.join(\"|\"),e.__patterns__=t;var i=e.__call__;e.__call__=function(e,n){return void 0!=n?i.call(this,e,n):i.call(this,e,t)}},t.DialectHelpers={},t.DialectHelpers.inline_until_char=function(e,t){for(var n=0,r=[];;){if(e.charAt(n)==t)return[++n,r];if(n>=e.length)return null;var i=this.dialect.inline.__oneElement__.call(this,e.substr(n));n+=i[0],r.push.apply(r,i.slice(1))}},t.subclassDialect=function(e){function t(){}function n(){}return t.prototype=e.block,n.prototype=e.inline,{block:new t,inline:new n}},t.buildBlockOrder(t.dialects.Gruber.block),t.buildInlinePatterns(t.dialects.Gruber.inline),t.dialects.Maruku=t.subclassDialect(t.dialects.Gruber),t.dialects.Maruku.processMetaHash=function(e){for(var t=function(e){var t=e.split(\"\"),n=[\"\"],r=!1;for(;t.length;){var i=t.shift();switch(i){case\" \":r?n[n.length-1]+=i:n.push(\"\");break;case\"'\":case'\"':r=!r;break;case\"\\\\\":i=t.shift();default:n[n.length-1]+=i}}return n}(e),n={},r=0;r<t.length;++r)if(/^#/.test(t[r]))n.id=t[r].substring(1);else if(/^\\./.test(t[r]))n.class?n.class=n.class+t[r].replace(/./,\" \"):n.class=t[r].substring(1);else if(/\\=/.test(t[r])){var i=t[r].split(/\\=/);n[i[0]]=i[1]}return n},t.dialects.Maruku.block.document_meta=function(e,t){if(!(e.lineNumber>1)&&e.match(/^(?:\\w+:.*\\n)*\\w+:.*$/)){f(this.tree)||this.tree.splice(1,0,{});var n=e.split(/\\n/);for(p in n){var r=n[p].match(/(\\w+):\\s*(.*)$/),i=r[1].toLowerCase(),l=r[2];this.tree[1][i]=l}return[]}},t.dialects.Maruku.block.block_meta=function(e,t){var n=e.match(/(^|\\n) {0,3}\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}$/);if(n){var r,i=this.dialect.processMetaHash(n[2]);if(\"\"===n[1]){var l=this.tree[this.tree.length-1];if(r=f(l),\"string\"===typeof l)return;for(a in r||(r={},l.splice(1,0,r)),i)r[a]=i[a];return[]}var s=e.replace(/\\n.*$/,\"\"),o=this.processBlock(s,[]);for(a in(r=f(o[0]))||(r={},o[0].splice(1,0,r)),i)r[a]=i[a];return o}},t.dialects.Maruku.block.definition_list=function(e,t){var n,r=/^((?:[^\\s:].*\\n)+):\\s+([\\s\\S]+)$/,i=[\"dl\"];if(a=e.match(r)){for(var l=[e];t.length&&r.exec(t[0]);)l.push(t.shift());for(var s=0;s<l.length;++s){var a,o=(a=l[s].match(r))[1].replace(/\\n$/,\"\").split(/\\n/),c=a[2].split(/\\n:\\s+/);for(n=0;n<o.length;++n)i.push([\"dt\",o[n]]);for(n=0;n<c.length;++n)i.push([\"dd\"].concat(this.processInline(c[n].replace(/(\\n)\\s+/,\"$1\"))))}return[i]}},t.dialects.Maruku.block.table=function(e,t){var n,r,i=function(e,t){(t=t||\"\\\\s\").match(/^[\\\\|\\[\\]{}?*.+^$]$/)&&(t=\"\\\\\"+t);for(var n,r=[],i=new RegExp(\"^((?:\\\\\\\\.|[^\\\\\\\\\"+t+\"])*)\"+t+\"(.*)\");n=e.match(i);)r.push(n[1]),e=n[2];return r.push(e),r};if(r=e.match(/^ {0,3}\\|(.+)\\n {0,3}\\|\\s*([\\-:]+[\\-| :]*)\\n((?:\\s*\\|.*(?:\\n|$))*)(?=\\n|$)/))r[3]=r[3].replace(/^\\s*\\|/gm,\"\");else if(!(r=e.match(/^ {0,3}(\\S(?:\\\\.|[^\\\\|])*\\|.*)\\n {0,3}([\\-:]+\\s*\\|[\\-| :]*)\\n((?:(?:\\\\.|[^\\\\|])*\\|.*(?:\\n|$))*)(?=\\n|$)/)))return;var l=[\"table\",[\"thead\",[\"tr\"]],[\"tbody\"]];r[2]=r[2].replace(/\\|\\s*$/,\"\").split(\"|\");var s=[];for(c(r[2],(function(e){e.match(/^\\s*-+:\\s*$/)?s.push({align:\"right\"}):e.match(/^\\s*:-+\\s*$/)?s.push({align:\"left\"}):e.match(/^\\s*:-+:\\s*$/)?s.push({align:\"center\"}):s.push({})})),r[1]=i(r[1].replace(/\\|\\s*$/,\"\"),\"|\"),n=0;n<r[1].length;n++)l[1][1].push([\"th\",s[n]||{}].concat(this.processInline(r[1][n].trim())));return c(r[3].replace(/\\|\\s*$/gm,\"\").split(\"\\n\"),(function(e){var t=[\"tr\"];for(e=i(e,\"|\"),n=0;n<e.length;n++)t.push([\"td\",s[n]||{}].concat(this.processInline(e[n].trim())));l[2].push(t)}),this),[l]},t.dialects.Maruku.inline[\"{:\"]=function(e,t,n){if(!n.length)return[2,\"{:\"];var r=n[n.length-1];if(\"string\"===typeof r)return[2,\"{:\"];var i=e.match(/^\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}/);if(!i)return[2,\"{:\"];var l=this.dialect.processMetaHash(i[1]),s=f(r);for(var a in s||(s={},r.splice(1,0,s)),l)s[a]=l[a];return[i[0].length,\"\"]},t.dialects.Maruku.inline.__escape__=/^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-|:]/,t.buildBlockOrder(t.dialects.Maruku.block),t.buildInlinePatterns(t.dialects.Maruku.inline);var c,u=Array.isArray||function(e){return\"[object Array]\"==Object.prototype.toString.call(e)};c=Array.prototype.forEach?function(e,t,n){return e.forEach(t,n)}:function(e,t,n){for(var r=0;r<e.length;r++)t.call(n||e,e[r],r,e)};var h=function(e){for(var t in e)if(hasOwnProperty.call(e,t))return!1;return!0};function f(e){return u(e)&&e.length>1&&\"object\"===typeof e[1]&&!u(e[1])?e[1]:void 0}function g(e){return e.replace(/&/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\").replace(/\"/g,\"&quot;\").replace(/'/g,\"&#39;\")}function d(e){if(\"string\"===typeof e)return g(e);var t=e.shift(),n={},r=[];for(!e.length||\"object\"!==typeof e[0]||e[0]instanceof Array||(n=e.shift());e.length;)r.push(d(e.shift()));var i=\"\";for(var l in n)i+=\" \"+l+'=\"'+g(n[l])+'\"';return\"img\"==t||\"br\"==t||\"hr\"==t?\"<\"+t+i+\"/>\":\"<\"+t+i+\">\"+r.join(\"\")+\"</\"+t+\">\"}function v(e,t,n){var r;n=n||{};var i=e.slice(0);\"function\"===typeof n.preprocessTreeNode&&(i=n.preprocessTreeNode(i,t));var l=f(i);if(l){for(r in i[1]={},l)i[1][r]=l[r];l=i[1]}if(\"string\"===typeof i)return i;switch(i[0]){case\"header\":i[0]=\"h\"+i[1].level,delete i[1].level;break;case\"bulletlist\":i[0]=\"ul\";break;case\"numberlist\":i[0]=\"ol\";break;case\"listitem\":i[0]=\"li\";break;case\"para\":i[0]=\"p\";break;case\"markdown\":i[0]=\"html\",l&&delete l.references;break;case\"code_block\":i[0]=\"pre\",r=l?2:1;var s=[\"code\"];s.push.apply(s,i.splice(r,i.length-r)),i[r]=s;break;case\"inlinecode\":i[0]=\"code\";break;case\"img\":i[1].src=i[1].href,delete i[1].href;break;case\"linebreak\":i[0]=\"br\";break;case\"link\":i[0]=\"a\";break;case\"link_ref\":if(i[0]=\"a\",!(a=t[l.ref]))return l.original;delete l.ref,l.href=a.href,a.title&&(l.title=a.title),delete l.original;break;case\"img_ref\":var a;if(i[0]=\"img\",!(a=t[l.ref]))return l.original;delete l.ref,l.src=a.href,a.title&&(l.title=a.title),delete l.original}if(r=1,l){for(var o in i[1]){r=2;break}1===r&&i.splice(r,1)}for(;r<i.length;++r)i[r]=v(i[r],t,n);return i}function _(e){for(var t=f(e)?2:1;t<e.length;)\"string\"===typeof e[t]?t+1<e.length&&\"string\"===typeof e[t+1]?e[t]+=e.splice(t+1,1)[0]:++t:(_(e[t]),++t)}e.renderJsonML=function(e,t){(t=t||{}).root=t.root||!1;var n=[];if(t.root)n.push(d(e));else for(e.shift(),!e.length||\"object\"!==typeof e[0]||e[0]instanceof Array||e.shift();e.length;)n.push(d(e.shift()));return n.join(\"\\n\\n\")}}(t)},jdwX:function(e,t,n){t.markdown=n(\"jLCa\"),t.parse=t.markdown.toHTML},vGMu:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push([\"/markdown-to-html\",function(){return n(\"4g3d\")}])}},[[\"vGMu\",1,2,0,3,17]]]);","map":{"version":3,"sources":["static/chunks/pages/markdown-to-html-8f15456034684921c9fe.js"],"names":["_N_E","self","this","push","4g3d","module","__webpack_exports__","__webpack_require__","r","d","MarkdownToHtml","react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__","_components_ConversionPanel__WEBPACK_IMPORTED_MODULE_1__","react__WEBPACK_IMPORTED_MODULE_2__","markdown__WEBPACK_IMPORTED_MODULE_3__","transformer","Object","_ref","value","toHTML","editorTitle","editorLanguage","resultTitle","resultLanguage","resultEditorProps","previewElement","dangerouslySetInnerHTML","__html","8oxB","exports","cachedSetTimeout","cachedClearTimeout","process","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","call","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","Array","arguments","i","prototype","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","jLCa","expose","Markdown","dialect","dialects","Gruber","String","em_state","strong_state","debug_indent","mk_block_toSource","uneval","toString","trailing","lineNumber","mk_block_inspect","util","inspect","parse","source","toTree","options","input","toHTMLTree","renderJsonML","attrs","extract_attr","refs","references","html","convert_tree_to_html","merge_text_nodes","mk_block","block","trail","line","s","toSource","undefined","count_lines","str","n","indexOf","strong_em","tag","md","state_slot","other_slot","CloseTag","len_after","text","orig_match","shift","other","slice","state","unshift","res","processInline","substr","last","pop","split_blocks","startLine","replace","m","re","blocks","line_no","exec","lastIndex","processBlock","next","cbs","ord","__order__","__call__","isArray","debug","inline","custom_root","old_tree","tree","b","print","console","log","loop_re_over_block","cb","valueOf","atxHeader","match","header","level","setextHeader","code","ret","block_search","substring","join","horizRule","jsonml","lists","any_list","bullet_list","is_list_re","RegExp","indent_re","add","li","loose","nl","add_to","what","get_contained_blocks","depth","x","paragraphify","stack","list","last_li","splice","sublist","make_list","lines","split","li_accumulate","l","line_re","wanted_depth","Math","floor","found","indent","contained","forEach","next_block","hr","blockquote","prev","abutting","processedBlock","attr","isEmpty","referenceDefn","ref","toLowerCase","href","para","__oneElement__","patterns_or_re","previous_nodes","__patterns__","index","patterns","out","]","}","__escape__","\\","charAt","![","alt","original","[","orig","DialectHelpers","inline_until_char","link","consumed","children","url","open_parens","<","`","  \n","buildBlockOrder","buildInlinePatterns","fn","pattern","want","nodes","subclassDialect","Block","Inline","Maruku","processMetaHash","meta_string","meta","parts","in_quotes","letter","split_meta_hash","test","id","document_meta","pairs","p","key","block_meta","hash","node","a","result","definition_list","tight","terms","defns","table","_split_on_unescaped","ch","html_attrs","align","trim","row","html_row","matches","before","k","obj","arr","thisp","hasOwnProperty","escapeHTML","render_tree","attributes","content","tag_attrs","preprocessTreeNode","src","root","jdwX","markdown","vGMu","window","__NEXT_P"],"mappings":"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"},"name":"static/chunks/pages/markdown-to-html-8f15456034684921c9fe.js","input":"_N_E =\n(typeof self !== \"object\" ? self : this[\"webpackJsonp_N_E\"] = typeof self !== \"object\" ? self : this[\"webpackJsonp_N_E\"] || []).push([[81],{\n\n/***/ \"4g3d\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MarkdownToHtml; });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"nKUr\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_ConversionPanel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"sN8P\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"q1tI\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var markdown__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"jdwX\");\n/* harmony import */ var markdown__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(markdown__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\nfunction MarkdownToHtml() {\n  var transformer = Object(react__WEBPACK_IMPORTED_MODULE_2__[\"useCallback\"])(function (_ref) {\n    var value = _ref.value;\n    return markdown__WEBPACK_IMPORTED_MODULE_3__[\"markdown\"].toHTML(value);\n  }, []);\n  return /*#__PURE__*/Object(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsx\"])(_components_ConversionPanel__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"], {\n    transformer: transformer,\n    editorTitle: \"Markdown\",\n    editorLanguage: \"markdown\",\n    resultTitle: \"HTML\",\n    resultLanguage: \"html\",\n    resultEditorProps: {\n      previewElement: function previewElement(value) {\n        return /*#__PURE__*/Object(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsx\"])(\"div\", {\n          dangerouslySetInnerHTML: {\n            __html: value\n          }\n        });\n      }\n    }\n  });\n}\n\n/***/ }),\n\n/***/ \"8oxB\":\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n\n/***/ \"jLCa\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Released under MIT license\n// Copyright (c) 2009-2010 Dominic Baggott\n// Copyright (c) 2009-2010 Ash Berlin\n// Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)\n\n/*jshint browser:true, devel:true */\n\n(function( expose ) {\n\n/**\n *  class Markdown\n *\n *  Markdown processing in Javascript done right. We have very particular views\n *  on what constitutes 'right' which include:\n *\n *  - produces well-formed HTML (this means that em and strong nesting is\n *    important)\n *\n *  - has an intermediate representation to allow processing of parsed data (We\n *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).\n *\n *  - is easily extensible to add new dialects without having to rewrite the\n *    entire parsing mechanics\n *\n *  - has a good test suite\n *\n *  This implementation fulfills all of these (except that the test suite could\n *  do with expanding to automatically run all the fixtures from other Markdown\n *  implementations.)\n *\n *  ##### Intermediate Representation\n *\n *  *TODO* Talk about this :) Its JsonML, but document the node names we use.\n *\n *  [JsonML]: http://jsonml.org/ \"JSON Markup Language\"\n **/\nvar Markdown = expose.Markdown = function(dialect) {\n  switch (typeof dialect) {\n    case \"undefined\":\n      this.dialect = Markdown.dialects.Gruber;\n      break;\n    case \"object\":\n      this.dialect = dialect;\n      break;\n    default:\n      if ( dialect in Markdown.dialects ) {\n        this.dialect = Markdown.dialects[dialect];\n      }\n      else {\n        throw new Error(\"Unknown Markdown dialect '\" + String(dialect) + \"'\");\n      }\n      break;\n  }\n  this.em_state = [];\n  this.strong_state = [];\n  this.debug_indent = \"\";\n};\n\n/**\n *  parse( markdown, [dialect] ) -> JsonML\n *  - markdown (String): markdown string to parse\n *  - dialect (String | Dialect): the dialect to use, defaults to gruber\n *\n *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.\n **/\nexpose.parse = function( source, dialect ) {\n  // dialect will default if undefined\n  var md = new Markdown( dialect );\n  return md.toTree( source );\n};\n\n/**\n *  toHTML( markdown, [dialect]  ) -> String\n *  toHTML( md_tree ) -> String\n *  - markdown (String): markdown string to parse\n *  - md_tree (Markdown.JsonML): parsed markdown tree\n *\n *  Take markdown (either as a string or as a JsonML tree) and run it through\n *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.\n **/\nexpose.toHTML = function toHTML( source , dialect , options ) {\n  var input = expose.toHTMLTree( source , dialect , options );\n\n  return expose.renderJsonML( input );\n};\n\n/**\n *  toHTMLTree( markdown, [dialect] ) -> JsonML\n *  toHTMLTree( md_tree ) -> JsonML\n *  - markdown (String): markdown string to parse\n *  - dialect (String | Dialect): the dialect to use, defaults to gruber\n *  - md_tree (Markdown.JsonML): parsed markdown tree\n *\n *  Turn markdown into HTML, represented as a JsonML tree. If a string is given\n *  to this function, it is first parsed into a markdown tree by calling\n *  [[parse]].\n **/\nexpose.toHTMLTree = function toHTMLTree( input, dialect , options ) {\n  // convert string input to an MD tree\n  if ( typeof input ===\"string\" ) input = this.parse( input, dialect );\n\n  // Now convert the MD tree to an HTML tree\n\n  // remove references from the tree\n  var attrs = extract_attr( input ),\n      refs = {};\n\n  if ( attrs && attrs.references ) {\n    refs = attrs.references;\n  }\n\n  var html = convert_tree_to_html( input, refs , options );\n  merge_text_nodes( html );\n  return html;\n};\n\n// For Spidermonkey based engines\nfunction mk_block_toSource() {\n  return \"Markdown.mk_block( \" +\n          uneval(this.toString()) +\n          \", \" +\n          uneval(this.trailing) +\n          \", \" +\n          uneval(this.lineNumber) +\n          \" )\";\n}\n\n// node\nfunction mk_block_inspect() {\n  var util = __webpack_require__(\"7tlc\");\n  return \"Markdown.mk_block( \" +\n          util.inspect(this.toString()) +\n          \", \" +\n          util.inspect(this.trailing) +\n          \", \" +\n          util.inspect(this.lineNumber) +\n          \" )\";\n\n}\n\nvar mk_block = Markdown.mk_block = function(block, trail, line) {\n  // Be helpful for default case in tests.\n  if ( arguments.length == 1 ) trail = \"\\n\\n\";\n\n  var s = new String(block);\n  s.trailing = trail;\n  // To make it clear its not just a string\n  s.inspect = mk_block_inspect;\n  s.toSource = mk_block_toSource;\n\n  if ( line != undefined )\n    s.lineNumber = line;\n\n  return s;\n};\n\nfunction count_lines( str ) {\n  var n = 0, i = -1;\n  while ( ( i = str.indexOf(\"\\n\", i + 1) ) !== -1 ) n++;\n  return n;\n}\n\n// Internal - split source into rough blocks\nMarkdown.prototype.split_blocks = function splitBlocks( input, startLine ) {\n  input = input.replace(/(\\r\\n|\\n|\\r)/g, \"\\n\");\n  // [\\s\\S] matches _anything_ (newline or space)\n  // [^] is equivalent but doesn't work in IEs.\n  var re = /([\\s\\S]+?)($|\\n#|\\n(?:\\s*\\n|$)+)/g,\n      blocks = [],\n      m;\n\n  var line_no = 1;\n\n  if ( ( m = /^(\\s*\\n)/.exec(input) ) != null ) {\n    // skip (but count) leading blank lines\n    line_no += count_lines( m[0] );\n    re.lastIndex = m[0].length;\n  }\n\n  while ( ( m = re.exec(input) ) !== null ) {\n    if (m[2] == \"\\n#\") {\n      m[2] = \"\\n\";\n      re.lastIndex--;\n    }\n    blocks.push( mk_block( m[1], m[2], line_no ) );\n    line_no += count_lines( m[0] );\n  }\n\n  return blocks;\n};\n\n/**\n *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]\n *  - block (String): the block to process\n *  - next (Array): the following blocks\n *\n * Process `block` and return an array of JsonML nodes representing `block`.\n *\n * It does this by asking each block level function in the dialect to process\n * the block until one can. Succesful handling is indicated by returning an\n * array (with zero or more JsonML nodes), failure by a false value.\n *\n * Blocks handlers are responsible for calling [[Markdown#processInline]]\n * themselves as appropriate.\n *\n * If the blocks were split incorrectly or adjacent blocks need collapsing you\n * can adjust `next` in place using shift/splice etc.\n *\n * If any of this default behaviour is not right for the dialect, you can\n * define a `__call__` method on the dialect that will get invoked to handle\n * the block processing.\n */\nMarkdown.prototype.processBlock = function processBlock( block, next ) {\n  var cbs = this.dialect.block,\n      ord = cbs.__order__;\n\n  if ( \"__call__\" in cbs ) {\n    return cbs.__call__.call(this, block, next);\n  }\n\n  for ( var i = 0; i < ord.length; i++ ) {\n    //D:this.debug( \"Testing\", ord[i] );\n    var res = cbs[ ord[i] ].call( this, block, next );\n    if ( res ) {\n      //D:this.debug(\"  matched\");\n      if ( !isArray(res) || ( res.length > 0 && !( isArray(res[0]) ) ) )\n        this.debug(ord[i], \"didn't return a proper array\");\n      //D:this.debug( \"\" );\n      return res;\n    }\n  }\n\n  // Uhoh! no match! Should we throw an error?\n  return [];\n};\n\nMarkdown.prototype.processInline = function processInline( block ) {\n  return this.dialect.inline.__call__.call( this, String( block ) );\n};\n\n/**\n *  Markdown#toTree( source ) -> JsonML\n *  - source (String): markdown source to parse\n *\n *  Parse `source` into a JsonML tree representing the markdown document.\n **/\n// custom_tree means set this.tree to `custom_tree` and restore old value on return\nMarkdown.prototype.toTree = function toTree( source, custom_root ) {\n  var blocks = source instanceof Array ? source : this.split_blocks( source );\n\n  // Make tree a member variable so its easier to mess with in extensions\n  var old_tree = this.tree;\n  try {\n    this.tree = custom_root || this.tree || [ \"markdown\" ];\n\n    blocks:\n    while ( blocks.length ) {\n      var b = this.processBlock( blocks.shift(), blocks );\n\n      // Reference blocks and the like won't return any content\n      if ( !b.length ) continue blocks;\n\n      this.tree.push.apply( this.tree, b );\n    }\n    return this.tree;\n  }\n  finally {\n    if ( custom_root ) {\n      this.tree = old_tree;\n    }\n  }\n};\n\n// Noop by default\nMarkdown.prototype.debug = function () {\n  var args = Array.prototype.slice.call( arguments);\n  args.unshift(this.debug_indent);\n  if ( typeof print !== \"undefined\" )\n      print.apply( print, args );\n  if ( typeof console !== \"undefined\" && typeof console.log !== \"undefined\" )\n      console.log.apply( null, args );\n}\n\nMarkdown.prototype.loop_re_over_block = function( re, block, cb ) {\n  // Dont use /g regexps with this\n  var m,\n      b = block.valueOf();\n\n  while ( b.length && (m = re.exec(b) ) != null ) {\n    b = b.substr( m[0].length );\n    cb.call(this, m);\n  }\n  return b;\n};\n\n/**\n * Markdown.dialects\n *\n * Namespace of built-in dialects.\n **/\nMarkdown.dialects = {};\n\n/**\n * Markdown.dialects.Gruber\n *\n * The default dialect that follows the rules set out by John Gruber's\n * markdown.pl as closely as possible. Well actually we follow the behaviour of\n * that script which in some places is not exactly what the syntax web page\n * says.\n **/\nMarkdown.dialects.Gruber = {\n  block: {\n    atxHeader: function atxHeader( block, next ) {\n      var m = block.match( /^(#{1,6})\\s*(.*?)\\s*#*\\s*(?:\\n|$)/ );\n\n      if ( !m ) return undefined;\n\n      var header = [ \"header\", { level: m[ 1 ].length } ];\n      Array.prototype.push.apply(header, this.processInline(m[ 2 ]));\n\n      if ( m[0].length < block.length )\n        next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );\n\n      return [ header ];\n    },\n\n    setextHeader: function setextHeader( block, next ) {\n      var m = block.match( /^(.*)\\n([-=])\\2\\2+(?:\\n|$)/ );\n\n      if ( !m ) return undefined;\n\n      var level = ( m[ 2 ] === \"=\" ) ? 1 : 2;\n      var header = [ \"header\", { level : level }, m[ 1 ] ];\n\n      if ( m[0].length < block.length )\n        next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );\n\n      return [ header ];\n    },\n\n    code: function code( block, next ) {\n      // |    Foo\n      // |bar\n      // should be a code block followed by a paragraph. Fun\n      //\n      // There might also be adjacent code block to merge.\n\n      var ret = [],\n          re = /^(?: {0,3}\\t| {4})(.*)\\n?/,\n          lines;\n\n      // 4 spaces + content\n      if ( !block.match( re ) ) return undefined;\n\n      block_search:\n      do {\n        // Now pull out the rest of the lines\n        var b = this.loop_re_over_block(\n                  re, block.valueOf(), function( m ) { ret.push( m[1] ); } );\n\n        if ( b.length ) {\n          // Case alluded to in first comment. push it back on as a new block\n          next.unshift( mk_block(b, block.trailing) );\n          break block_search;\n        }\n        else if ( next.length ) {\n          // Check the next block - it might be code too\n          if ( !next[0].match( re ) ) break block_search;\n\n          // Pull how how many blanks lines follow - minus two to account for .join\n          ret.push ( block.trailing.replace(/[^\\n]/g, \"\").substring(2) );\n\n          block = next.shift();\n        }\n        else {\n          break block_search;\n        }\n      } while ( true );\n\n      return [ [ \"code_block\", ret.join(\"\\n\") ] ];\n    },\n\n    horizRule: function horizRule( block, next ) {\n      // this needs to find any hr in the block to handle abutting blocks\n      var m = block.match( /^(?:([\\s\\S]*?)\\n)?[ \\t]*([-_*])(?:[ \\t]*\\2){2,}[ \\t]*(?:\\n([\\s\\S]*))?$/ );\n\n      if ( !m ) {\n        return undefined;\n      }\n\n      var jsonml = [ [ \"hr\" ] ];\n\n      // if there's a leading abutting block, process it\n      if ( m[ 1 ] ) {\n        jsonml.unshift.apply( jsonml, this.processBlock( m[ 1 ], [] ) );\n      }\n\n      // if there's a trailing abutting block, stick it into next\n      if ( m[ 3 ] ) {\n        next.unshift( mk_block( m[ 3 ] ) );\n      }\n\n      return jsonml;\n    },\n\n    // There are two types of lists. Tight and loose. Tight lists have no whitespace\n    // between the items (and result in text just in the <li>) and loose lists,\n    // which have an empty line between list items, resulting in (one or more)\n    // paragraphs inside the <li>.\n    //\n    // There are all sorts weird edge cases about the original markdown.pl's\n    // handling of lists:\n    //\n    // * Nested lists are supposed to be indented by four chars per level. But\n    //   if they aren't, you can get a nested list by indenting by less than\n    //   four so long as the indent doesn't match an indent of an existing list\n    //   item in the 'nest stack'.\n    //\n    // * The type of the list (bullet or number) is controlled just by the\n    //    first item at the indent. Subsequent changes are ignored unless they\n    //    are for nested lists\n    //\n    lists: (function( ) {\n      // Use a closure to hide a few variables.\n      var any_list = \"[*+-]|\\\\d+\\\\.\",\n          bullet_list = /[*+-]/,\n          number_list = /\\d+\\./,\n          // Capture leading indent as it matters for determining nested lists.\n          is_list_re = new RegExp( \"^( {0,3})(\" + any_list + \")[ \\t]+\" ),\n          indent_re = \"(?: {0,3}\\\\t| {4})\";\n\n      // TODO: Cache this regexp for certain depths.\n      // Create a regexp suitable for matching an li for a given stack depth\n      function regex_for_depth( depth ) {\n\n        return new RegExp(\n          // m[1] = indent, m[2] = list_type\n          \"(?:^(\" + indent_re + \"{0,\" + depth + \"} {0,3})(\" + any_list + \")\\\\s+)|\" +\n          // m[3] = cont\n          \"(^\" + indent_re + \"{0,\" + (depth-1) + \"}[ ]{0,4})\"\n        );\n      }\n      function expand_tab( input ) {\n        return input.replace( / {0,3}\\t/g, \"    \" );\n      }\n\n      // Add inline content `inline` to `li`. inline comes from processInline\n      // so is an array of content\n      function add(li, loose, inline, nl) {\n        if ( loose ) {\n          li.push( [ \"para\" ].concat(inline) );\n          return;\n        }\n        // Hmmm, should this be any block level element or just paras?\n        var add_to = li[li.length -1] instanceof Array && li[li.length - 1][0] == \"para\"\n                   ? li[li.length -1]\n                   : li;\n\n        // If there is already some content in this list, add the new line in\n        if ( nl && li.length > 1 ) inline.unshift(nl);\n\n        for ( var i = 0; i < inline.length; i++ ) {\n          var what = inline[i],\n              is_str = typeof what == \"string\";\n          if ( is_str && add_to.length > 1 && typeof add_to[add_to.length-1] == \"string\" ) {\n            add_to[ add_to.length-1 ] += what;\n          }\n          else {\n            add_to.push( what );\n          }\n        }\n      }\n\n      // contained means have an indent greater than the current one. On\n      // *every* line in the block\n      function get_contained_blocks( depth, blocks ) {\n\n        var re = new RegExp( \"^(\" + indent_re + \"{\" + depth + \"}.*?\\\\n?)*$\" ),\n            replace = new RegExp(\"^\" + indent_re + \"{\" + depth + \"}\", \"gm\"),\n            ret = [];\n\n        while ( blocks.length > 0 ) {\n          if ( re.exec( blocks[0] ) ) {\n            var b = blocks.shift(),\n                // Now remove that indent\n                x = b.replace( replace, \"\");\n\n            ret.push( mk_block( x, b.trailing, b.lineNumber ) );\n          }\n          else {\n            break;\n          }\n        }\n        return ret;\n      }\n\n      // passed to stack.forEach to turn list items up the stack into paras\n      function paragraphify(s, i, stack) {\n        var list = s.list;\n        var last_li = list[list.length-1];\n\n        if ( last_li[1] instanceof Array && last_li[1][0] == \"para\" ) {\n          return;\n        }\n        if ( i + 1 == stack.length ) {\n          // Last stack frame\n          // Keep the same array, but replace the contents\n          last_li.push( [\"para\"].concat( last_li.splice(1, last_li.length - 1) ) );\n        }\n        else {\n          var sublist = last_li.pop();\n          last_li.push( [\"para\"].concat( last_li.splice(1, last_li.length - 1) ), sublist );\n        }\n      }\n\n      // The matcher function\n      return function( block, next ) {\n        var m = block.match( is_list_re );\n        if ( !m ) return undefined;\n\n        function make_list( m ) {\n          var list = bullet_list.exec( m[2] )\n                   ? [\"bulletlist\"]\n                   : [\"numberlist\"];\n\n          stack.push( { list: list, indent: m[1] } );\n          return list;\n        }\n\n\n        var stack = [], // Stack of lists for nesting.\n            list = make_list( m ),\n            last_li,\n            loose = false,\n            ret = [ stack[0].list ],\n            i;\n\n        // Loop to search over block looking for inner block elements and loose lists\n        loose_search:\n        while ( true ) {\n          // Split into lines preserving new lines at end of line\n          var lines = block.split( /(?=\\n)/ );\n\n          // We have to grab all lines for a li and call processInline on them\n          // once as there are some inline things that can span lines.\n          var li_accumulate = \"\";\n\n          // Loop over the lines in this block looking for tight lists.\n          tight_search:\n          for ( var line_no = 0; line_no < lines.length; line_no++ ) {\n            var nl = \"\",\n                l = lines[line_no].replace(/^\\n/, function(n) { nl = n; return \"\"; });\n\n            // TODO: really should cache this\n            var line_re = regex_for_depth( stack.length );\n\n            m = l.match( line_re );\n            //print( \"line:\", uneval(l), \"\\nline match:\", uneval(m) );\n\n            // We have a list item\n            if ( m[1] !== undefined ) {\n              // Process the previous list item, if any\n              if ( li_accumulate.length ) {\n                add( last_li, loose, this.processInline( li_accumulate ), nl );\n                // Loose mode will have been dealt with. Reset it\n                loose = false;\n                li_accumulate = \"\";\n              }\n\n              m[1] = expand_tab( m[1] );\n              var wanted_depth = Math.floor(m[1].length/4)+1;\n              //print( \"want:\", wanted_depth, \"stack:\", stack.length);\n              if ( wanted_depth > stack.length ) {\n                // Deep enough for a nested list outright\n                //print ( \"new nested list\" );\n                list = make_list( m );\n                last_li.push( list );\n                last_li = list[1] = [ \"listitem\" ];\n              }\n              else {\n                // We aren't deep enough to be strictly a new level. This is\n                // where Md.pl goes nuts. If the indent matches a level in the\n                // stack, put it there, else put it one deeper then the\n                // wanted_depth deserves.\n                var found = false;\n                for ( i = 0; i < stack.length; i++ ) {\n                  if ( stack[ i ].indent != m[1] ) continue;\n                  list = stack[ i ].list;\n                  stack.splice( i+1, stack.length - (i+1) );\n                  found = true;\n                  break;\n                }\n\n                if (!found) {\n                  //print(\"not found. l:\", uneval(l));\n                  wanted_depth++;\n                  if ( wanted_depth <= stack.length ) {\n                    stack.splice(wanted_depth, stack.length - wanted_depth);\n                    //print(\"Desired depth now\", wanted_depth, \"stack:\", stack.length);\n                    list = stack[wanted_depth-1].list;\n                    //print(\"list:\", uneval(list) );\n                  }\n                  else {\n                    //print (\"made new stack for messy indent\");\n                    list = make_list(m);\n                    last_li.push(list);\n                  }\n                }\n\n                //print( uneval(list), \"last\", list === stack[stack.length-1].list );\n                last_li = [ \"listitem\" ];\n                list.push(last_li);\n              } // end depth of shenegains\n              nl = \"\";\n            }\n\n            // Add content\n            if ( l.length > m[0].length ) {\n              li_accumulate += nl + l.substr( m[0].length );\n            }\n          } // tight_search\n\n          if ( li_accumulate.length ) {\n            add( last_li, loose, this.processInline( li_accumulate ), nl );\n            // Loose mode will have been dealt with. Reset it\n            loose = false;\n            li_accumulate = \"\";\n          }\n\n          // Look at the next block - we might have a loose list. Or an extra\n          // paragraph for the current li\n          var contained = get_contained_blocks( stack.length, next );\n\n          // Deal with code blocks or properly nested lists\n          if ( contained.length > 0 ) {\n            // Make sure all listitems up the stack are paragraphs\n            forEach( stack, paragraphify, this);\n\n            last_li.push.apply( last_li, this.toTree( contained, [] ) );\n          }\n\n          var next_block = next[0] && next[0].valueOf() || \"\";\n\n          if ( next_block.match(is_list_re) || next_block.match( /^ / ) ) {\n            block = next.shift();\n\n            // Check for an HR following a list: features/lists/hr_abutting\n            var hr = this.dialect.block.horizRule( block, next );\n\n            if ( hr ) {\n              ret.push.apply(ret, hr);\n              break;\n            }\n\n            // Make sure all listitems up the stack are paragraphs\n            forEach( stack, paragraphify, this);\n\n            loose = true;\n            continue loose_search;\n          }\n          break;\n        } // loose_search\n\n        return ret;\n      };\n    })(),\n\n    blockquote: function blockquote( block, next ) {\n      if ( !block.match( /^>/m ) )\n        return undefined;\n\n      var jsonml = [];\n\n      // separate out the leading abutting block, if any. I.e. in this case:\n      //\n      //  a\n      //  > b\n      //\n      if ( block[ 0 ] != \">\" ) {\n        var lines = block.split( /\\n/ ),\n            prev = [],\n            line_no = block.lineNumber;\n\n        // keep shifting lines until you find a crotchet\n        while ( lines.length && lines[ 0 ][ 0 ] != \">\" ) {\n            prev.push( lines.shift() );\n            line_no++;\n        }\n\n        var abutting = mk_block( prev.join( \"\\n\" ), \"\\n\", block.lineNumber );\n        jsonml.push.apply( jsonml, this.processBlock( abutting, [] ) );\n        // reassemble new block of just block quotes!\n        block = mk_block( lines.join( \"\\n\" ), block.trailing, line_no );\n      }\n\n\n      // if the next block is also a blockquote merge it in\n      while ( next.length && next[ 0 ][ 0 ] == \">\" ) {\n        var b = next.shift();\n        block = mk_block( block + block.trailing + b, b.trailing, block.lineNumber );\n      }\n\n      // Strip off the leading \"> \" and re-process as a block.\n      var input = block.replace( /^> ?/gm, \"\" ),\n          old_tree = this.tree,\n          processedBlock = this.toTree( input, [ \"blockquote\" ] ),\n          attr = extract_attr( processedBlock );\n\n      // If any link references were found get rid of them\n      if ( attr && attr.references ) {\n        delete attr.references;\n        // And then remove the attribute object if it's empty\n        if ( isEmpty( attr ) ) {\n          processedBlock.splice( 1, 1 );\n        }\n      }\n\n      jsonml.push( processedBlock );\n      return jsonml;\n    },\n\n    referenceDefn: function referenceDefn( block, next) {\n      var re = /^\\s*\\[(.*?)\\]:\\s*(\\S+)(?:\\s+(?:(['\"])(.*?)\\3|\\((.*?)\\)))?\\n?/;\n      // interesting matches are [ , ref_id, url, , title, title ]\n\n      if ( !block.match(re) )\n        return undefined;\n\n      // make an attribute node if it doesn't exist\n      if ( !extract_attr( this.tree ) ) {\n        this.tree.splice( 1, 0, {} );\n      }\n\n      var attrs = extract_attr( this.tree );\n\n      // make a references hash if it doesn't exist\n      if ( attrs.references === undefined ) {\n        attrs.references = {};\n      }\n\n      var b = this.loop_re_over_block(re, block, function( m ) {\n\n        if ( m[2] && m[2][0] == \"<\" && m[2][m[2].length-1] == \">\" )\n          m[2] = m[2].substring( 1, m[2].length - 1 );\n\n        var ref = attrs.references[ m[1].toLowerCase() ] = {\n          href: m[2]\n        };\n\n        if ( m[4] !== undefined )\n          ref.title = m[4];\n        else if ( m[5] !== undefined )\n          ref.title = m[5];\n\n      } );\n\n      if ( b.length )\n        next.unshift( mk_block( b, block.trailing ) );\n\n      return [];\n    },\n\n    para: function para( block, next ) {\n      // everything's a para!\n      return [ [\"para\"].concat( this.processInline( block ) ) ];\n    }\n  }\n};\n\nMarkdown.dialects.Gruber.inline = {\n\n    __oneElement__: function oneElement( text, patterns_or_re, previous_nodes ) {\n      var m,\n          res,\n          lastIndex = 0;\n\n      patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;\n      var re = new RegExp( \"([\\\\s\\\\S]*?)(\" + (patterns_or_re.source || patterns_or_re) + \")\" );\n\n      m = re.exec( text );\n      if (!m) {\n        // Just boring text\n        return [ text.length, text ];\n      }\n      else if ( m[1] ) {\n        // Some un-interesting text matched. Return that first\n        return [ m[1].length, m[1] ];\n      }\n\n      var res;\n      if ( m[2] in this.dialect.inline ) {\n        res = this.dialect.inline[ m[2] ].call(\n                  this,\n                  text.substr( m.index ), m, previous_nodes || [] );\n      }\n      // Default for now to make dev easier. just slurp special and output it.\n      res = res || [ m[2].length, m[2] ];\n      return res;\n    },\n\n    __call__: function inline( text, patterns ) {\n\n      var out = [],\n          res;\n\n      function add(x) {\n        //D:self.debug(\"  adding output\", uneval(x));\n        if ( typeof x == \"string\" && typeof out[out.length-1] == \"string\" )\n          out[ out.length-1 ] += x;\n        else\n          out.push(x);\n      }\n\n      while ( text.length > 0 ) {\n        res = this.dialect.inline.__oneElement__.call(this, text, patterns, out );\n        text = text.substr( res.shift() );\n        forEach(res, add )\n      }\n\n      return out;\n    },\n\n    // These characters are intersting elsewhere, so have rules for them so that\n    // chunks of plain text blocks don't include them\n    \"]\": function () {},\n    \"}\": function () {},\n\n    __escape__ : /^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-]/,\n\n    \"\\\\\": function escaped( text ) {\n      // [ length of input processed, node/children to add... ]\n      // Only esacape: \\ ` * _ { } [ ] ( ) # * + - . !\n      if ( this.dialect.inline.__escape__.exec( text ) )\n        return [ 2, text.charAt( 1 ) ];\n      else\n        // Not an esacpe\n        return [ 1, \"\\\\\" ];\n    },\n\n    \"![\": function image( text ) {\n\n      // Unlike images, alt text is plain text only. no other elements are\n      // allowed in there\n\n      // ![Alt text](/path/to/img.jpg \"Optional title\")\n      //      1          2            3       4         <--- captures\n      var m = text.match( /^!\\[(.*?)\\][ \\t]*\\([ \\t]*([^\")]*?)(?:[ \\t]+([\"'])(.*?)\\3)?[ \\t]*\\)/ );\n\n      if ( m ) {\n        if ( m[2] && m[2][0] == \"<\" && m[2][m[2].length-1] == \">\" )\n          m[2] = m[2].substring( 1, m[2].length - 1 );\n\n        m[2] = this.dialect.inline.__call__.call( this, m[2], /\\\\/ )[0];\n\n        var attrs = { alt: m[1], href: m[2] || \"\" };\n        if ( m[4] !== undefined)\n          attrs.title = m[4];\n\n        return [ m[0].length, [ \"img\", attrs ] ];\n      }\n\n      // ![Alt text][id]\n      m = text.match( /^!\\[(.*?)\\][ \\t]*\\[(.*?)\\]/ );\n\n      if ( m ) {\n        // We can't check if the reference is known here as it likely wont be\n        // found till after. Check it in md tree->hmtl tree conversion\n        return [ m[0].length, [ \"img_ref\", { alt: m[1], ref: m[2].toLowerCase(), original: m[0] } ] ];\n      }\n\n      // Just consume the '!['\n      return [ 2, \"![\" ];\n    },\n\n    \"[\": function link( text ) {\n\n      var orig = String(text);\n      // Inline content is possible inside `link text`\n      var res = Markdown.DialectHelpers.inline_until_char.call( this, text.substr(1), \"]\" );\n\n      // No closing ']' found. Just consume the [\n      if ( !res ) return [ 1, \"[\" ];\n\n      var consumed = 1 + res[ 0 ],\n          children = res[ 1 ],\n          link,\n          attrs;\n\n      // At this point the first [...] has been parsed. See what follows to find\n      // out which kind of link we are (reference or direct url)\n      text = text.substr( consumed );\n\n      // [link text](/path/to/img.jpg \"Optional title\")\n      //                 1            2       3         <--- captures\n      // This will capture up to the last paren in the block. We then pull\n      // back based on if there a matching ones in the url\n      //    ([here](/url/(test))\n      // The parens have to be balanced\n      var m = text.match( /^\\s*\\([ \\t]*([^\"']*)(?:[ \\t]+([\"'])(.*?)\\2)?[ \\t]*\\)/ );\n      if ( m ) {\n        var url = m[1];\n        consumed += m[0].length;\n\n        if ( url && url[0] == \"<\" && url[url.length-1] == \">\" )\n          url = url.substring( 1, url.length - 1 );\n\n        // If there is a title we don't have to worry about parens in the url\n        if ( !m[3] ) {\n          var open_parens = 1; // One open that isn't in the capture\n          for ( var len = 0; len < url.length; len++ ) {\n            switch ( url[len] ) {\n            case \"(\":\n              open_parens++;\n              break;\n            case \")\":\n              if ( --open_parens == 0) {\n                consumed -= url.length - len;\n                url = url.substring(0, len);\n              }\n              break;\n            }\n          }\n        }\n\n        // Process escapes only\n        url = this.dialect.inline.__call__.call( this, url, /\\\\/ )[0];\n\n        attrs = { href: url || \"\" };\n        if ( m[3] !== undefined)\n          attrs.title = m[3];\n\n        link = [ \"link\", attrs ].concat( children );\n        return [ consumed, link ];\n      }\n\n      // [Alt text][id]\n      // [Alt text] [id]\n      m = text.match( /^\\s*\\[(.*?)\\]/ );\n\n      if ( m ) {\n\n        consumed += m[ 0 ].length;\n\n        // [links][] uses links as its reference\n        attrs = { ref: ( m[ 1 ] || String(children) ).toLowerCase(),  original: orig.substr( 0, consumed ) };\n\n        link = [ \"link_ref\", attrs ].concat( children );\n\n        // We can't check if the reference is known here as it likely wont be\n        // found till after. Check it in md tree->hmtl tree conversion.\n        // Store the original so that conversion can revert if the ref isn't found.\n        return [ consumed, link ];\n      }\n\n      // [id]\n      // Only if id is plain (no formatting.)\n      if ( children.length == 1 && typeof children[0] == \"string\" ) {\n\n        attrs = { ref: children[0].toLowerCase(),  original: orig.substr( 0, consumed ) };\n        link = [ \"link_ref\", attrs, children[0] ];\n        return [ consumed, link ];\n      }\n\n      // Just consume the \"[\"\n      return [ 1, \"[\" ];\n    },\n\n\n    \"<\": function autoLink( text ) {\n      var m;\n\n      if ( ( m = text.match( /^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\\.[a-zA-Z]+))>/ ) ) != null ) {\n        if ( m[3] ) {\n          return [ m[0].length, [ \"link\", { href: \"mailto:\" + m[3] }, m[3] ] ];\n\n        }\n        else if ( m[2] == \"mailto\" ) {\n          return [ m[0].length, [ \"link\", { href: m[1] }, m[1].substr(\"mailto:\".length ) ] ];\n        }\n        else\n          return [ m[0].length, [ \"link\", { href: m[1] }, m[1] ] ];\n      }\n\n      return [ 1, \"<\" ];\n    },\n\n    \"`\": function inlineCode( text ) {\n      // Inline code block. as many backticks as you like to start it\n      // Always skip over the opening ticks.\n      var m = text.match( /(`+)(([\\s\\S]*?)\\1)/ );\n\n      if ( m && m[2] )\n        return [ m[1].length + m[2].length, [ \"inlinecode\", m[3] ] ];\n      else {\n        // TODO: No matching end code found - warn!\n        return [ 1, \"`\" ];\n      }\n    },\n\n    \"  \\n\": function lineBreak( text ) {\n      return [ 3, [ \"linebreak\" ] ];\n    }\n\n};\n\n// Meta Helper/generator method for em and strong handling\nfunction strong_em( tag, md ) {\n\n  var state_slot = tag + \"_state\",\n      other_slot = tag == \"strong\" ? \"em_state\" : \"strong_state\";\n\n  function CloseTag(len) {\n    this.len_after = len;\n    this.name = \"close_\" + md;\n  }\n\n  return function ( text, orig_match ) {\n\n    if ( this[state_slot][0] == md ) {\n      // Most recent em is of this type\n      //D:this.debug(\"closing\", md);\n      this[state_slot].shift();\n\n      // \"Consume\" everything to go back to the recrusion in the else-block below\n      return[ text.length, new CloseTag(text.length-md.length) ];\n    }\n    else {\n      // Store a clone of the em/strong states\n      var other = this[other_slot].slice(),\n          state = this[state_slot].slice();\n\n      this[state_slot].unshift(md);\n\n      //D:this.debug_indent += \"  \";\n\n      // Recurse\n      var res = this.processInline( text.substr( md.length ) );\n      //D:this.debug_indent = this.debug_indent.substr(2);\n\n      var last = res[res.length - 1];\n\n      //D:this.debug(\"processInline from\", tag + \": \", uneval( res ) );\n\n      var check = this[state_slot].shift();\n      if ( last instanceof CloseTag ) {\n        res.pop();\n        // We matched! Huzzah.\n        var consumed = text.length - last.len_after;\n        return [ consumed, [ tag ].concat(res) ];\n      }\n      else {\n        // Restore the state of the other kind. We might have mistakenly closed it.\n        this[other_slot] = other;\n        this[state_slot] = state;\n\n        // We can't reuse the processed result as it could have wrong parsing contexts in it.\n        return [ md.length, md ];\n      }\n    }\n  }; // End returned function\n}\n\nMarkdown.dialects.Gruber.inline[\"**\"] = strong_em(\"strong\", \"**\");\nMarkdown.dialects.Gruber.inline[\"__\"] = strong_em(\"strong\", \"__\");\nMarkdown.dialects.Gruber.inline[\"*\"]  = strong_em(\"em\", \"*\");\nMarkdown.dialects.Gruber.inline[\"_\"]  = strong_em(\"em\", \"_\");\n\n\n// Build default order from insertion order.\nMarkdown.buildBlockOrder = function(d) {\n  var ord = [];\n  for ( var i in d ) {\n    if ( i == \"__order__\" || i == \"__call__\" ) continue;\n    ord.push( i );\n  }\n  d.__order__ = ord;\n};\n\n// Build patterns for inline matcher\nMarkdown.buildInlinePatterns = function(d) {\n  var patterns = [];\n\n  for ( var i in d ) {\n    // __foo__ is reserved and not a pattern\n    if ( i.match( /^__.*__$/) ) continue;\n    var l = i.replace( /([\\\\.*+?|()\\[\\]{}])/g, \"\\\\$1\" )\n             .replace( /\\n/, \"\\\\n\" );\n    patterns.push( i.length == 1 ? l : \"(?:\" + l + \")\" );\n  }\n\n  patterns = patterns.join(\"|\");\n  d.__patterns__ = patterns;\n  //print(\"patterns:\", uneval( patterns ) );\n\n  var fn = d.__call__;\n  d.__call__ = function(text, pattern) {\n    if ( pattern != undefined ) {\n      return fn.call(this, text, pattern);\n    }\n    else\n    {\n      return fn.call(this, text, patterns);\n    }\n  };\n};\n\nMarkdown.DialectHelpers = {};\nMarkdown.DialectHelpers.inline_until_char = function( text, want ) {\n  var consumed = 0,\n      nodes = [];\n\n  while ( true ) {\n    if ( text.charAt( consumed ) == want ) {\n      // Found the character we were looking for\n      consumed++;\n      return [ consumed, nodes ];\n    }\n\n    if ( consumed >= text.length ) {\n      // No closing char found. Abort.\n      return null;\n    }\n\n    var res = this.dialect.inline.__oneElement__.call(this, text.substr( consumed ) );\n    consumed += res[ 0 ];\n    // Add any returned nodes.\n    nodes.push.apply( nodes, res.slice( 1 ) );\n  }\n}\n\n// Helper function to make sub-classing a dialect easier\nMarkdown.subclassDialect = function( d ) {\n  function Block() {}\n  Block.prototype = d.block;\n  function Inline() {}\n  Inline.prototype = d.inline;\n\n  return { block: new Block(), inline: new Inline() };\n};\n\nMarkdown.buildBlockOrder ( Markdown.dialects.Gruber.block );\nMarkdown.buildInlinePatterns( Markdown.dialects.Gruber.inline );\n\nMarkdown.dialects.Maruku = Markdown.subclassDialect( Markdown.dialects.Gruber );\n\nMarkdown.dialects.Maruku.processMetaHash = function processMetaHash( meta_string ) {\n  var meta = split_meta_hash( meta_string ),\n      attr = {};\n\n  for ( var i = 0; i < meta.length; ++i ) {\n    // id: #foo\n    if ( /^#/.test( meta[ i ] ) ) {\n      attr.id = meta[ i ].substring( 1 );\n    }\n    // class: .foo\n    else if ( /^\\./.test( meta[ i ] ) ) {\n      // if class already exists, append the new one\n      if ( attr[\"class\"] ) {\n        attr[\"class\"] = attr[\"class\"] + meta[ i ].replace( /./, \" \" );\n      }\n      else {\n        attr[\"class\"] = meta[ i ].substring( 1 );\n      }\n    }\n    // attribute: foo=bar\n    else if ( /\\=/.test( meta[ i ] ) ) {\n      var s = meta[ i ].split( /\\=/ );\n      attr[ s[ 0 ] ] = s[ 1 ];\n    }\n  }\n\n  return attr;\n}\n\nfunction split_meta_hash( meta_string ) {\n  var meta = meta_string.split( \"\" ),\n      parts = [ \"\" ],\n      in_quotes = false;\n\n  while ( meta.length ) {\n    var letter = meta.shift();\n    switch ( letter ) {\n      case \" \" :\n        // if we're in a quoted section, keep it\n        if ( in_quotes ) {\n          parts[ parts.length - 1 ] += letter;\n        }\n        // otherwise make a new part\n        else {\n          parts.push( \"\" );\n        }\n        break;\n      case \"'\" :\n      case '\"' :\n        // reverse the quotes and move straight on\n        in_quotes = !in_quotes;\n        break;\n      case \"\\\\\" :\n        // shift off the next letter to be used straight away.\n        // it was escaped so we'll keep it whatever it is\n        letter = meta.shift();\n      default :\n        parts[ parts.length - 1 ] += letter;\n        break;\n    }\n  }\n\n  return parts;\n}\n\nMarkdown.dialects.Maruku.block.document_meta = function document_meta( block, next ) {\n  // we're only interested in the first block\n  if ( block.lineNumber > 1 ) return undefined;\n\n  // document_meta blocks consist of one or more lines of `Key: Value\\n`\n  if ( ! block.match( /^(?:\\w+:.*\\n)*\\w+:.*$/ ) ) return undefined;\n\n  // make an attribute node if it doesn't exist\n  if ( !extract_attr( this.tree ) ) {\n    this.tree.splice( 1, 0, {} );\n  }\n\n  var pairs = block.split( /\\n/ );\n  for ( p in pairs ) {\n    var m = pairs[ p ].match( /(\\w+):\\s*(.*)$/ ),\n        key = m[ 1 ].toLowerCase(),\n        value = m[ 2 ];\n\n    this.tree[ 1 ][ key ] = value;\n  }\n\n  // document_meta produces no content!\n  return [];\n};\n\nMarkdown.dialects.Maruku.block.block_meta = function block_meta( block, next ) {\n  // check if the last line of the block is an meta hash\n  var m = block.match( /(^|\\n) {0,3}\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}$/ );\n  if ( !m ) return undefined;\n\n  // process the meta hash\n  var attr = this.dialect.processMetaHash( m[ 2 ] );\n\n  var hash;\n\n  // if we matched ^ then we need to apply meta to the previous block\n  if ( m[ 1 ] === \"\" ) {\n    var node = this.tree[ this.tree.length - 1 ];\n    hash = extract_attr( node );\n\n    // if the node is a string (rather than JsonML), bail\n    if ( typeof node === \"string\" ) return undefined;\n\n    // create the attribute hash if it doesn't exist\n    if ( !hash ) {\n      hash = {};\n      node.splice( 1, 0, hash );\n    }\n\n    // add the attributes in\n    for ( a in attr ) {\n      hash[ a ] = attr[ a ];\n    }\n\n    // return nothing so the meta hash is removed\n    return [];\n  }\n\n  // pull the meta hash off the block and process what's left\n  var b = block.replace( /\\n.*$/, \"\" ),\n      result = this.processBlock( b, [] );\n\n  // get or make the attributes hash\n  hash = extract_attr( result[ 0 ] );\n  if ( !hash ) {\n    hash = {};\n    result[ 0 ].splice( 1, 0, hash );\n  }\n\n  // attach the attributes to the block\n  for ( a in attr ) {\n    hash[ a ] = attr[ a ];\n  }\n\n  return result;\n};\n\nMarkdown.dialects.Maruku.block.definition_list = function definition_list( block, next ) {\n  // one or more terms followed by one or more definitions, in a single block\n  var tight = /^((?:[^\\s:].*\\n)+):\\s+([\\s\\S]+)$/,\n      list = [ \"dl\" ],\n      i, m;\n\n  // see if we're dealing with a tight or loose block\n  if ( ( m = block.match( tight ) ) ) {\n    // pull subsequent tight DL blocks out of `next`\n    var blocks = [ block ];\n    while ( next.length && tight.exec( next[ 0 ] ) ) {\n      blocks.push( next.shift() );\n    }\n\n    for ( var b = 0; b < blocks.length; ++b ) {\n      var m = blocks[ b ].match( tight ),\n          terms = m[ 1 ].replace( /\\n$/, \"\" ).split( /\\n/ ),\n          defns = m[ 2 ].split( /\\n:\\s+/ );\n\n      // print( uneval( m ) );\n\n      for ( i = 0; i < terms.length; ++i ) {\n        list.push( [ \"dt\", terms[ i ] ] );\n      }\n\n      for ( i = 0; i < defns.length; ++i ) {\n        // run inline processing over the definition\n        list.push( [ \"dd\" ].concat( this.processInline( defns[ i ].replace( /(\\n)\\s+/, \"$1\" ) ) ) );\n      }\n    }\n  }\n  else {\n    return undefined;\n  }\n\n  return [ list ];\n};\n\n// splits on unescaped instances of @ch. If @ch is not a character the result\n// can be unpredictable\n\nMarkdown.dialects.Maruku.block.table = function table (block, next) {\n\n    var _split_on_unescaped = function(s, ch) {\n        ch = ch || '\\\\s';\n        if (ch.match(/^[\\\\|\\[\\]{}?*.+^$]$/)) { ch = '\\\\' + ch; }\n        var res = [ ],\n            r = new RegExp('^((?:\\\\\\\\.|[^\\\\\\\\' + ch + '])*)' + ch + '(.*)'),\n            m;\n        while(m = s.match(r)) {\n            res.push(m[1]);\n            s = m[2];\n        }\n        res.push(s);\n        return res;\n    }\n\n    var leading_pipe = /^ {0,3}\\|(.+)\\n {0,3}\\|\\s*([\\-:]+[\\-| :]*)\\n((?:\\s*\\|.*(?:\\n|$))*)(?=\\n|$)/,\n        // find at least an unescaped pipe in each line\n        no_leading_pipe = /^ {0,3}(\\S(?:\\\\.|[^\\\\|])*\\|.*)\\n {0,3}([\\-:]+\\s*\\|[\\-| :]*)\\n((?:(?:\\\\.|[^\\\\|])*\\|.*(?:\\n|$))*)(?=\\n|$)/,\n        i, m;\n    if (m = block.match(leading_pipe)) {\n        // remove leading pipes in contents\n        // (header and horizontal rule already have the leading pipe left out)\n        m[3] = m[3].replace(/^\\s*\\|/gm, '');\n    } else if (! ( m = block.match(no_leading_pipe))) {\n        return undefined;\n    }\n\n    var table = [ \"table\", [ \"thead\", [ \"tr\" ] ], [ \"tbody\" ] ];\n\n    // remove trailing pipes, then split on pipes\n    // (no escaped pipes are allowed in horizontal rule)\n    m[2] = m[2].replace(/\\|\\s*$/, '').split('|');\n\n    // process alignment\n    var html_attrs = [ ];\n    forEach (m[2], function (s) {\n        if (s.match(/^\\s*-+:\\s*$/))       html_attrs.push({align: \"right\"});\n        else if (s.match(/^\\s*:-+\\s*$/))  html_attrs.push({align: \"left\"});\n        else if (s.match(/^\\s*:-+:\\s*$/)) html_attrs.push({align: \"center\"});\n        else                              html_attrs.push({});\n    });\n\n    // now for the header, avoid escaped pipes\n    m[1] = _split_on_unescaped(m[1].replace(/\\|\\s*$/, ''), '|');\n    for (i = 0; i < m[1].length; i++) {\n        table[1][1].push(['th', html_attrs[i] || {}].concat(\n            this.processInline(m[1][i].trim())));\n    }\n\n    // now for body contents\n    forEach (m[3].replace(/\\|\\s*$/mg, '').split('\\n'), function (row) {\n        var html_row = ['tr'];\n        row = _split_on_unescaped(row, '|');\n        for (i = 0; i < row.length; i++) {\n            html_row.push(['td', html_attrs[i] || {}].concat(this.processInline(row[i].trim())));\n        }\n        table[2].push(html_row);\n    }, this);\n\n    return [table];\n}\n\nMarkdown.dialects.Maruku.inline[ \"{:\" ] = function inline_meta( text, matches, out ) {\n  if ( !out.length ) {\n    return [ 2, \"{:\" ];\n  }\n\n  // get the preceeding element\n  var before = out[ out.length - 1 ];\n\n  if ( typeof before === \"string\" ) {\n    return [ 2, \"{:\" ];\n  }\n\n  // match a meta hash\n  var m = text.match( /^\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}/ );\n\n  // no match, false alarm\n  if ( !m ) {\n    return [ 2, \"{:\" ];\n  }\n\n  // attach the attributes to the preceeding element\n  var meta = this.dialect.processMetaHash( m[ 1 ] ),\n      attr = extract_attr( before );\n\n  if ( !attr ) {\n    attr = {};\n    before.splice( 1, 0, attr );\n  }\n\n  for ( var k in meta ) {\n    attr[ k ] = meta[ k ];\n  }\n\n  // cut out the string and replace it with nothing\n  return [ m[ 0 ].length, \"\" ];\n};\n\nMarkdown.dialects.Maruku.inline.__escape__ = /^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-|:]/;\n\nMarkdown.buildBlockOrder ( Markdown.dialects.Maruku.block );\nMarkdown.buildInlinePatterns( Markdown.dialects.Maruku.inline );\n\nvar isArray = Array.isArray || function(obj) {\n  return Object.prototype.toString.call(obj) == \"[object Array]\";\n};\n\nvar forEach;\n// Don't mess with Array.prototype. Its not friendly\nif ( Array.prototype.forEach ) {\n  forEach = function( arr, cb, thisp ) {\n    return arr.forEach( cb, thisp );\n  };\n}\nelse {\n  forEach = function(arr, cb, thisp) {\n    for (var i = 0; i < arr.length; i++) {\n      cb.call(thisp || arr, arr[i], i, arr);\n    }\n  }\n}\n\nvar isEmpty = function( obj ) {\n  for ( var key in obj ) {\n    if ( hasOwnProperty.call( obj, key ) ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction extract_attr( jsonml ) {\n  return isArray(jsonml)\n      && jsonml.length > 1\n      && typeof jsonml[ 1 ] === \"object\"\n      && !( isArray(jsonml[ 1 ]) )\n      ? jsonml[ 1 ]\n      : undefined;\n}\n\n\n\n/**\n *  renderJsonML( jsonml[, options] ) -> String\n *  - jsonml (Array): JsonML array to render to XML\n *  - options (Object): options\n *\n *  Converts the given JsonML into well-formed XML.\n *\n *  The options currently understood are:\n *\n *  - root (Boolean): wether or not the root node should be included in the\n *    output, or just its children. The default `false` is to not include the\n *    root itself.\n */\nexpose.renderJsonML = function( jsonml, options ) {\n  options = options || {};\n  // include the root element in the rendered output?\n  options.root = options.root || false;\n\n  var content = [];\n\n  if ( options.root ) {\n    content.push( render_tree( jsonml ) );\n  }\n  else {\n    jsonml.shift(); // get rid of the tag\n    if ( jsonml.length && typeof jsonml[ 0 ] === \"object\" && !( jsonml[ 0 ] instanceof Array ) ) {\n      jsonml.shift(); // get rid of the attributes\n    }\n\n    while ( jsonml.length ) {\n      content.push( render_tree( jsonml.shift() ) );\n    }\n  }\n\n  return content.join( \"\\n\\n\" );\n};\n\nfunction escapeHTML( text ) {\n  return text.replace( /&/g, \"&amp;\" )\n             .replace( /</g, \"&lt;\" )\n             .replace( />/g, \"&gt;\" )\n             .replace( /\"/g, \"&quot;\" )\n             .replace( /'/g, \"&#39;\" );\n}\n\nfunction render_tree( jsonml ) {\n  // basic case\n  if ( typeof jsonml === \"string\" ) {\n    return escapeHTML( jsonml );\n  }\n\n  var tag = jsonml.shift(),\n      attributes = {},\n      content = [];\n\n  if ( jsonml.length && typeof jsonml[ 0 ] === \"object\" && !( jsonml[ 0 ] instanceof Array ) ) {\n    attributes = jsonml.shift();\n  }\n\n  while ( jsonml.length ) {\n    content.push( render_tree( jsonml.shift() ) );\n  }\n\n  var tag_attrs = \"\";\n  for ( var a in attributes ) {\n    tag_attrs += \" \" + a + '=\"' + escapeHTML( attributes[ a ] ) + '\"';\n  }\n\n  // be careful about adding whitespace here for inline elements\n  if ( tag == \"img\" || tag == \"br\" || tag == \"hr\" ) {\n    return \"<\"+ tag + tag_attrs + \"/>\";\n  }\n  else {\n    return \"<\"+ tag + tag_attrs + \">\" + content.join( \"\" ) + \"</\" + tag + \">\";\n  }\n}\n\nfunction convert_tree_to_html( tree, references, options ) {\n  var i;\n  options = options || {};\n\n  // shallow clone\n  var jsonml = tree.slice( 0 );\n\n  if ( typeof options.preprocessTreeNode === \"function\" ) {\n      jsonml = options.preprocessTreeNode(jsonml, references);\n  }\n\n  // Clone attributes if they exist\n  var attrs = extract_attr( jsonml );\n  if ( attrs ) {\n    jsonml[ 1 ] = {};\n    for ( i in attrs ) {\n      jsonml[ 1 ][ i ] = attrs[ i ];\n    }\n    attrs = jsonml[ 1 ];\n  }\n\n  // basic case\n  if ( typeof jsonml === \"string\" ) {\n    return jsonml;\n  }\n\n  // convert this node\n  switch ( jsonml[ 0 ] ) {\n    case \"header\":\n      jsonml[ 0 ] = \"h\" + jsonml[ 1 ].level;\n      delete jsonml[ 1 ].level;\n      break;\n    case \"bulletlist\":\n      jsonml[ 0 ] = \"ul\";\n      break;\n    case \"numberlist\":\n      jsonml[ 0 ] = \"ol\";\n      break;\n    case \"listitem\":\n      jsonml[ 0 ] = \"li\";\n      break;\n    case \"para\":\n      jsonml[ 0 ] = \"p\";\n      break;\n    case \"markdown\":\n      jsonml[ 0 ] = \"html\";\n      if ( attrs ) delete attrs.references;\n      break;\n    case \"code_block\":\n      jsonml[ 0 ] = \"pre\";\n      i = attrs ? 2 : 1;\n      var code = [ \"code\" ];\n      code.push.apply( code, jsonml.splice( i, jsonml.length - i ) );\n      jsonml[ i ] = code;\n      break;\n    case \"inlinecode\":\n      jsonml[ 0 ] = \"code\";\n      break;\n    case \"img\":\n      jsonml[ 1 ].src = jsonml[ 1 ].href;\n      delete jsonml[ 1 ].href;\n      break;\n    case \"linebreak\":\n      jsonml[ 0 ] = \"br\";\n    break;\n    case \"link\":\n      jsonml[ 0 ] = \"a\";\n      break;\n    case \"link_ref\":\n      jsonml[ 0 ] = \"a\";\n\n      // grab this ref and clean up the attribute node\n      var ref = references[ attrs.ref ];\n\n      // if the reference exists, make the link\n      if ( ref ) {\n        delete attrs.ref;\n\n        // add in the href and title, if present\n        attrs.href = ref.href;\n        if ( ref.title ) {\n          attrs.title = ref.title;\n        }\n\n        // get rid of the unneeded original text\n        delete attrs.original;\n      }\n      // the reference doesn't exist, so revert to plain text\n      else {\n        return attrs.original;\n      }\n      break;\n    case \"img_ref\":\n      jsonml[ 0 ] = \"img\";\n\n      // grab this ref and clean up the attribute node\n      var ref = references[ attrs.ref ];\n\n      // if the reference exists, make the link\n      if ( ref ) {\n        delete attrs.ref;\n\n        // add in the href and title, if present\n        attrs.src = ref.href;\n        if ( ref.title ) {\n          attrs.title = ref.title;\n        }\n\n        // get rid of the unneeded original text\n        delete attrs.original;\n      }\n      // the reference doesn't exist, so revert to plain text\n      else {\n        return attrs.original;\n      }\n      break;\n  }\n\n  // convert all the children\n  i = 1;\n\n  // deal with the attribute node, if it exists\n  if ( attrs ) {\n    // if there are keys, skip over it\n    for ( var key in jsonml[ 1 ] ) {\n        i = 2;\n        break;\n    }\n    // if there aren't, remove it\n    if ( i === 1 ) {\n      jsonml.splice( i, 1 );\n    }\n  }\n\n  for ( ; i < jsonml.length; ++i ) {\n    jsonml[ i ] = convert_tree_to_html( jsonml[ i ], references, options );\n  }\n\n  return jsonml;\n}\n\n\n// merges adjacent text nodes into a single node\nfunction merge_text_nodes( jsonml ) {\n  // skip the tag name and attribute hash\n  var i = extract_attr( jsonml ) ? 2 : 1;\n\n  while ( i < jsonml.length ) {\n    // if it's a string check the next item too\n    if ( typeof jsonml[ i ] === \"string\" ) {\n      if ( i + 1 < jsonml.length && typeof jsonml[ i + 1 ] === \"string\" ) {\n        // merge the second string into the first and remove it\n        jsonml[ i ] += jsonml.splice( i + 1, 1 )[ 0 ];\n      }\n      else {\n        ++i;\n      }\n    }\n    // if it's not a string recurse\n    else {\n      merge_text_nodes( jsonml[ i ] );\n      ++i;\n    }\n  }\n}\n\n} )( (function() {\n  if ( false ) {}\n  else {\n    return exports;\n  }\n} )() );\n\n\n/***/ }),\n\n/***/ \"jdwX\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// super simple module for the most common nodejs use case.\nexports.markdown = __webpack_require__(\"jLCa\");\nexports.parse = exports.markdown.toHTML;\n\n\n/***/ }),\n\n/***/ \"vGMu\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/markdown-to-html\",\n      function () {\n        return __webpack_require__(\"4g3d\");\n      }\n    ]);\n  \n\n/***/ })\n\n},[[\"vGMu\",1,2,0,3,17]]]);","inputSourceMap":{"version":3,"sources":["/Users/songxu/Develop/test/transform/node_modules/next/dist/build/webpack/loaders/next-babel-loader.js??ref--5!/Users/songxu/Develop/test/transform/pages/markdown-to-html.tsx","/Users/songxu/Develop/test/transform/node_modules/process/browser.js","/Users/songxu/Develop/test/transform/node_modules/markdown/lib/markdown.js","/Users/songxu/Develop/test/transform/node_modules/markdown/lib/index.js","/Users/songxu/Develop/test/transform/node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Fmarkdown-to-html&absolutePagePath=private-next-pages%2Fmarkdown-to-html.tsx!"],"names":[],"mappings":";;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgD;AACU;AACtB;AACL;AACK;AACrB;AACf,oBAAoB,yDAAW;AAC/B;AACA,WAAW,iDAAQ;AACnB,GAAG;AACH,sBAAsB,6DAAI,CAAC,2EAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAI;AAChC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH,C;;;;;;;AC1BA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;ACvLtC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,mBAAO,CAAC,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,IAAI;;AAEpC;;AAEA,gCAAgC,uBAAuB;AACvD;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA,gCAAgC,gBAAgB;;AAEhD;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,IAAI,KAAK,EAAE;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sDAAsD,kBAAkB,EAAE;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;AACA,wEAAwE,GAAG;;AAE3E;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,IAAI;AAC5C,4BAA4B,IAAI,MAAM,EAAE;;AAExC;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,gBAAgB,EAAE,IAAI;AACxD;AACA,+BAA+B,oBAAoB,IAAI,IAAI;AAC3D;AACA;AACA;AACA,iCAAiC,IAAI;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD,cAAc;AAChE,qDAAqD,cAAc;AACnE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA,+DAA+D,QAAQ,WAAW,EAAE;;AAEpF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,OAAO;;AAEP;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,uBAAuB;AACvB,MAAM,iBAAiB;;AAEvB,8BAA8B;;AAE9B;AACA;AACA,gCAAgC,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,qDAAqD;AACjG;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;;AAEA;AACA;AACA,2CAA2C,yBAAyB;;AAEpE;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA,2CAA2C,aAAa;AACxD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,IAAI,EAAE,YAAY,KAAK,SAAS;AAChE;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;AACA;;AAEA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,iCAAiC,aAAa,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,IAAI,UAAU,IAAI;AAC7C;AACA,8BAA8B,IAAI,2BAA2B,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D,eAAe;AAC1E,2DAA2D,cAAc;AACzE,2DAA2D,gBAAgB;AAC3E,4DAA4D;AAC5D,KAAK;;AAEL;AACA;AACA,eAAe,iBAAiB;AAChC,mDAAmD;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,oDAAoD;AACpD;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,mCAAmC;AACnC;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;AACA,kBAAkB;AAClB;;AAEA;AACA,0BAA0B,YAAY,KAAK,SAAS;;AAEpD;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0DAA0D;;AAE1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC;AACnC,kCAAkC;AAClC,kCAAkC;AAClC,oCAAoC;AACpC,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,mBAAmB;AAC5B;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD,OAAO,KAA8B,GAAG,EAGrC;AACH;AACA;AACA;AACA,CAAC;;;;;;;;AC5rDD;AACA,mBAAmB,mBAAO,CAAC,MAAY;AACvC;;;;;;;;;ACDA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,MAAyC;AAChE;AACA","file":"x","sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport ConversionPanel from \"@components/ConversionPanel\";\nimport { useCallback } from \"react\";\nimport * as React from \"react\";\nimport { markdown } from \"markdown\";\nexport default function MarkdownToHtml() {\n  var transformer = useCallback(function (_ref) {\n    var value = _ref.value;\n    return markdown.toHTML(value);\n  }, []);\n  return /*#__PURE__*/_jsx(ConversionPanel, {\n    transformer: transformer,\n    editorTitle: \"Markdown\",\n    editorLanguage: \"markdown\",\n    resultTitle: \"HTML\",\n    resultLanguage: \"html\",\n    resultEditorProps: {\n      previewElement: function previewElement(value) {\n        return /*#__PURE__*/_jsx(\"div\", {\n          dangerouslySetInnerHTML: {\n            __html: value\n          }\n        });\n      }\n    }\n  });\n}","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","// Released under MIT license\n// Copyright (c) 2009-2010 Dominic Baggott\n// Copyright (c) 2009-2010 Ash Berlin\n// Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)\n\n/*jshint browser:true, devel:true */\n\n(function( expose ) {\n\n/**\n *  class Markdown\n *\n *  Markdown processing in Javascript done right. We have very particular views\n *  on what constitutes 'right' which include:\n *\n *  - produces well-formed HTML (this means that em and strong nesting is\n *    important)\n *\n *  - has an intermediate representation to allow processing of parsed data (We\n *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).\n *\n *  - is easily extensible to add new dialects without having to rewrite the\n *    entire parsing mechanics\n *\n *  - has a good test suite\n *\n *  This implementation fulfills all of these (except that the test suite could\n *  do with expanding to automatically run all the fixtures from other Markdown\n *  implementations.)\n *\n *  ##### Intermediate Representation\n *\n *  *TODO* Talk about this :) Its JsonML, but document the node names we use.\n *\n *  [JsonML]: http://jsonml.org/ \"JSON Markup Language\"\n **/\nvar Markdown = expose.Markdown = function(dialect) {\n  switch (typeof dialect) {\n    case \"undefined\":\n      this.dialect = Markdown.dialects.Gruber;\n      break;\n    case \"object\":\n      this.dialect = dialect;\n      break;\n    default:\n      if ( dialect in Markdown.dialects ) {\n        this.dialect = Markdown.dialects[dialect];\n      }\n      else {\n        throw new Error(\"Unknown Markdown dialect '\" + String(dialect) + \"'\");\n      }\n      break;\n  }\n  this.em_state = [];\n  this.strong_state = [];\n  this.debug_indent = \"\";\n};\n\n/**\n *  parse( markdown, [dialect] ) -> JsonML\n *  - markdown (String): markdown string to parse\n *  - dialect (String | Dialect): the dialect to use, defaults to gruber\n *\n *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.\n **/\nexpose.parse = function( source, dialect ) {\n  // dialect will default if undefined\n  var md = new Markdown( dialect );\n  return md.toTree( source );\n};\n\n/**\n *  toHTML( markdown, [dialect]  ) -> String\n *  toHTML( md_tree ) -> String\n *  - markdown (String): markdown string to parse\n *  - md_tree (Markdown.JsonML): parsed markdown tree\n *\n *  Take markdown (either as a string or as a JsonML tree) and run it through\n *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.\n **/\nexpose.toHTML = function toHTML( source , dialect , options ) {\n  var input = expose.toHTMLTree( source , dialect , options );\n\n  return expose.renderJsonML( input );\n};\n\n/**\n *  toHTMLTree( markdown, [dialect] ) -> JsonML\n *  toHTMLTree( md_tree ) -> JsonML\n *  - markdown (String): markdown string to parse\n *  - dialect (String | Dialect): the dialect to use, defaults to gruber\n *  - md_tree (Markdown.JsonML): parsed markdown tree\n *\n *  Turn markdown into HTML, represented as a JsonML tree. If a string is given\n *  to this function, it is first parsed into a markdown tree by calling\n *  [[parse]].\n **/\nexpose.toHTMLTree = function toHTMLTree( input, dialect , options ) {\n  // convert string input to an MD tree\n  if ( typeof input ===\"string\" ) input = this.parse( input, dialect );\n\n  // Now convert the MD tree to an HTML tree\n\n  // remove references from the tree\n  var attrs = extract_attr( input ),\n      refs = {};\n\n  if ( attrs && attrs.references ) {\n    refs = attrs.references;\n  }\n\n  var html = convert_tree_to_html( input, refs , options );\n  merge_text_nodes( html );\n  return html;\n};\n\n// For Spidermonkey based engines\nfunction mk_block_toSource() {\n  return \"Markdown.mk_block( \" +\n          uneval(this.toString()) +\n          \", \" +\n          uneval(this.trailing) +\n          \", \" +\n          uneval(this.lineNumber) +\n          \" )\";\n}\n\n// node\nfunction mk_block_inspect() {\n  var util = require(\"util\");\n  return \"Markdown.mk_block( \" +\n          util.inspect(this.toString()) +\n          \", \" +\n          util.inspect(this.trailing) +\n          \", \" +\n          util.inspect(this.lineNumber) +\n          \" )\";\n\n}\n\nvar mk_block = Markdown.mk_block = function(block, trail, line) {\n  // Be helpful for default case in tests.\n  if ( arguments.length == 1 ) trail = \"\\n\\n\";\n\n  var s = new String(block);\n  s.trailing = trail;\n  // To make it clear its not just a string\n  s.inspect = mk_block_inspect;\n  s.toSource = mk_block_toSource;\n\n  if ( line != undefined )\n    s.lineNumber = line;\n\n  return s;\n};\n\nfunction count_lines( str ) {\n  var n = 0, i = -1;\n  while ( ( i = str.indexOf(\"\\n\", i + 1) ) !== -1 ) n++;\n  return n;\n}\n\n// Internal - split source into rough blocks\nMarkdown.prototype.split_blocks = function splitBlocks( input, startLine ) {\n  input = input.replace(/(\\r\\n|\\n|\\r)/g, \"\\n\");\n  // [\\s\\S] matches _anything_ (newline or space)\n  // [^] is equivalent but doesn't work in IEs.\n  var re = /([\\s\\S]+?)($|\\n#|\\n(?:\\s*\\n|$)+)/g,\n      blocks = [],\n      m;\n\n  var line_no = 1;\n\n  if ( ( m = /^(\\s*\\n)/.exec(input) ) != null ) {\n    // skip (but count) leading blank lines\n    line_no += count_lines( m[0] );\n    re.lastIndex = m[0].length;\n  }\n\n  while ( ( m = re.exec(input) ) !== null ) {\n    if (m[2] == \"\\n#\") {\n      m[2] = \"\\n\";\n      re.lastIndex--;\n    }\n    blocks.push( mk_block( m[1], m[2], line_no ) );\n    line_no += count_lines( m[0] );\n  }\n\n  return blocks;\n};\n\n/**\n *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]\n *  - block (String): the block to process\n *  - next (Array): the following blocks\n *\n * Process `block` and return an array of JsonML nodes representing `block`.\n *\n * It does this by asking each block level function in the dialect to process\n * the block until one can. Succesful handling is indicated by returning an\n * array (with zero or more JsonML nodes), failure by a false value.\n *\n * Blocks handlers are responsible for calling [[Markdown#processInline]]\n * themselves as appropriate.\n *\n * If the blocks were split incorrectly or adjacent blocks need collapsing you\n * can adjust `next` in place using shift/splice etc.\n *\n * If any of this default behaviour is not right for the dialect, you can\n * define a `__call__` method on the dialect that will get invoked to handle\n * the block processing.\n */\nMarkdown.prototype.processBlock = function processBlock( block, next ) {\n  var cbs = this.dialect.block,\n      ord = cbs.__order__;\n\n  if ( \"__call__\" in cbs ) {\n    return cbs.__call__.call(this, block, next);\n  }\n\n  for ( var i = 0; i < ord.length; i++ ) {\n    //D:this.debug( \"Testing\", ord[i] );\n    var res = cbs[ ord[i] ].call( this, block, next );\n    if ( res ) {\n      //D:this.debug(\"  matched\");\n      if ( !isArray(res) || ( res.length > 0 && !( isArray(res[0]) ) ) )\n        this.debug(ord[i], \"didn't return a proper array\");\n      //D:this.debug( \"\" );\n      return res;\n    }\n  }\n\n  // Uhoh! no match! Should we throw an error?\n  return [];\n};\n\nMarkdown.prototype.processInline = function processInline( block ) {\n  return this.dialect.inline.__call__.call( this, String( block ) );\n};\n\n/**\n *  Markdown#toTree( source ) -> JsonML\n *  - source (String): markdown source to parse\n *\n *  Parse `source` into a JsonML tree representing the markdown document.\n **/\n// custom_tree means set this.tree to `custom_tree` and restore old value on return\nMarkdown.prototype.toTree = function toTree( source, custom_root ) {\n  var blocks = source instanceof Array ? source : this.split_blocks( source );\n\n  // Make tree a member variable so its easier to mess with in extensions\n  var old_tree = this.tree;\n  try {\n    this.tree = custom_root || this.tree || [ \"markdown\" ];\n\n    blocks:\n    while ( blocks.length ) {\n      var b = this.processBlock( blocks.shift(), blocks );\n\n      // Reference blocks and the like won't return any content\n      if ( !b.length ) continue blocks;\n\n      this.tree.push.apply( this.tree, b );\n    }\n    return this.tree;\n  }\n  finally {\n    if ( custom_root ) {\n      this.tree = old_tree;\n    }\n  }\n};\n\n// Noop by default\nMarkdown.prototype.debug = function () {\n  var args = Array.prototype.slice.call( arguments);\n  args.unshift(this.debug_indent);\n  if ( typeof print !== \"undefined\" )\n      print.apply( print, args );\n  if ( typeof console !== \"undefined\" && typeof console.log !== \"undefined\" )\n      console.log.apply( null, args );\n}\n\nMarkdown.prototype.loop_re_over_block = function( re, block, cb ) {\n  // Dont use /g regexps with this\n  var m,\n      b = block.valueOf();\n\n  while ( b.length && (m = re.exec(b) ) != null ) {\n    b = b.substr( m[0].length );\n    cb.call(this, m);\n  }\n  return b;\n};\n\n/**\n * Markdown.dialects\n *\n * Namespace of built-in dialects.\n **/\nMarkdown.dialects = {};\n\n/**\n * Markdown.dialects.Gruber\n *\n * The default dialect that follows the rules set out by John Gruber's\n * markdown.pl as closely as possible. Well actually we follow the behaviour of\n * that script which in some places is not exactly what the syntax web page\n * says.\n **/\nMarkdown.dialects.Gruber = {\n  block: {\n    atxHeader: function atxHeader( block, next ) {\n      var m = block.match( /^(#{1,6})\\s*(.*?)\\s*#*\\s*(?:\\n|$)/ );\n\n      if ( !m ) return undefined;\n\n      var header = [ \"header\", { level: m[ 1 ].length } ];\n      Array.prototype.push.apply(header, this.processInline(m[ 2 ]));\n\n      if ( m[0].length < block.length )\n        next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );\n\n      return [ header ];\n    },\n\n    setextHeader: function setextHeader( block, next ) {\n      var m = block.match( /^(.*)\\n([-=])\\2\\2+(?:\\n|$)/ );\n\n      if ( !m ) return undefined;\n\n      var level = ( m[ 2 ] === \"=\" ) ? 1 : 2;\n      var header = [ \"header\", { level : level }, m[ 1 ] ];\n\n      if ( m[0].length < block.length )\n        next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );\n\n      return [ header ];\n    },\n\n    code: function code( block, next ) {\n      // |    Foo\n      // |bar\n      // should be a code block followed by a paragraph. Fun\n      //\n      // There might also be adjacent code block to merge.\n\n      var ret = [],\n          re = /^(?: {0,3}\\t| {4})(.*)\\n?/,\n          lines;\n\n      // 4 spaces + content\n      if ( !block.match( re ) ) return undefined;\n\n      block_search:\n      do {\n        // Now pull out the rest of the lines\n        var b = this.loop_re_over_block(\n                  re, block.valueOf(), function( m ) { ret.push( m[1] ); } );\n\n        if ( b.length ) {\n          // Case alluded to in first comment. push it back on as a new block\n          next.unshift( mk_block(b, block.trailing) );\n          break block_search;\n        }\n        else if ( next.length ) {\n          // Check the next block - it might be code too\n          if ( !next[0].match( re ) ) break block_search;\n\n          // Pull how how many blanks lines follow - minus two to account for .join\n          ret.push ( block.trailing.replace(/[^\\n]/g, \"\").substring(2) );\n\n          block = next.shift();\n        }\n        else {\n          break block_search;\n        }\n      } while ( true );\n\n      return [ [ \"code_block\", ret.join(\"\\n\") ] ];\n    },\n\n    horizRule: function horizRule( block, next ) {\n      // this needs to find any hr in the block to handle abutting blocks\n      var m = block.match( /^(?:([\\s\\S]*?)\\n)?[ \\t]*([-_*])(?:[ \\t]*\\2){2,}[ \\t]*(?:\\n([\\s\\S]*))?$/ );\n\n      if ( !m ) {\n        return undefined;\n      }\n\n      var jsonml = [ [ \"hr\" ] ];\n\n      // if there's a leading abutting block, process it\n      if ( m[ 1 ] ) {\n        jsonml.unshift.apply( jsonml, this.processBlock( m[ 1 ], [] ) );\n      }\n\n      // if there's a trailing abutting block, stick it into next\n      if ( m[ 3 ] ) {\n        next.unshift( mk_block( m[ 3 ] ) );\n      }\n\n      return jsonml;\n    },\n\n    // There are two types of lists. Tight and loose. Tight lists have no whitespace\n    // between the items (and result in text just in the <li>) and loose lists,\n    // which have an empty line between list items, resulting in (one or more)\n    // paragraphs inside the <li>.\n    //\n    // There are all sorts weird edge cases about the original markdown.pl's\n    // handling of lists:\n    //\n    // * Nested lists are supposed to be indented by four chars per level. But\n    //   if they aren't, you can get a nested list by indenting by less than\n    //   four so long as the indent doesn't match an indent of an existing list\n    //   item in the 'nest stack'.\n    //\n    // * The type of the list (bullet or number) is controlled just by the\n    //    first item at the indent. Subsequent changes are ignored unless they\n    //    are for nested lists\n    //\n    lists: (function( ) {\n      // Use a closure to hide a few variables.\n      var any_list = \"[*+-]|\\\\d+\\\\.\",\n          bullet_list = /[*+-]/,\n          number_list = /\\d+\\./,\n          // Capture leading indent as it matters for determining nested lists.\n          is_list_re = new RegExp( \"^( {0,3})(\" + any_list + \")[ \\t]+\" ),\n          indent_re = \"(?: {0,3}\\\\t| {4})\";\n\n      // TODO: Cache this regexp for certain depths.\n      // Create a regexp suitable for matching an li for a given stack depth\n      function regex_for_depth( depth ) {\n\n        return new RegExp(\n          // m[1] = indent, m[2] = list_type\n          \"(?:^(\" + indent_re + \"{0,\" + depth + \"} {0,3})(\" + any_list + \")\\\\s+)|\" +\n          // m[3] = cont\n          \"(^\" + indent_re + \"{0,\" + (depth-1) + \"}[ ]{0,4})\"\n        );\n      }\n      function expand_tab( input ) {\n        return input.replace( / {0,3}\\t/g, \"    \" );\n      }\n\n      // Add inline content `inline` to `li`. inline comes from processInline\n      // so is an array of content\n      function add(li, loose, inline, nl) {\n        if ( loose ) {\n          li.push( [ \"para\" ].concat(inline) );\n          return;\n        }\n        // Hmmm, should this be any block level element or just paras?\n        var add_to = li[li.length -1] instanceof Array && li[li.length - 1][0] == \"para\"\n                   ? li[li.length -1]\n                   : li;\n\n        // If there is already some content in this list, add the new line in\n        if ( nl && li.length > 1 ) inline.unshift(nl);\n\n        for ( var i = 0; i < inline.length; i++ ) {\n          var what = inline[i],\n              is_str = typeof what == \"string\";\n          if ( is_str && add_to.length > 1 && typeof add_to[add_to.length-1] == \"string\" ) {\n            add_to[ add_to.length-1 ] += what;\n          }\n          else {\n            add_to.push( what );\n          }\n        }\n      }\n\n      // contained means have an indent greater than the current one. On\n      // *every* line in the block\n      function get_contained_blocks( depth, blocks ) {\n\n        var re = new RegExp( \"^(\" + indent_re + \"{\" + depth + \"}.*?\\\\n?)*$\" ),\n            replace = new RegExp(\"^\" + indent_re + \"{\" + depth + \"}\", \"gm\"),\n            ret = [];\n\n        while ( blocks.length > 0 ) {\n          if ( re.exec( blocks[0] ) ) {\n            var b = blocks.shift(),\n                // Now remove that indent\n                x = b.replace( replace, \"\");\n\n            ret.push( mk_block( x, b.trailing, b.lineNumber ) );\n          }\n          else {\n            break;\n          }\n        }\n        return ret;\n      }\n\n      // passed to stack.forEach to turn list items up the stack into paras\n      function paragraphify(s, i, stack) {\n        var list = s.list;\n        var last_li = list[list.length-1];\n\n        if ( last_li[1] instanceof Array && last_li[1][0] == \"para\" ) {\n          return;\n        }\n        if ( i + 1 == stack.length ) {\n          // Last stack frame\n          // Keep the same array, but replace the contents\n          last_li.push( [\"para\"].concat( last_li.splice(1, last_li.length - 1) ) );\n        }\n        else {\n          var sublist = last_li.pop();\n          last_li.push( [\"para\"].concat( last_li.splice(1, last_li.length - 1) ), sublist );\n        }\n      }\n\n      // The matcher function\n      return function( block, next ) {\n        var m = block.match( is_list_re );\n        if ( !m ) return undefined;\n\n        function make_list( m ) {\n          var list = bullet_list.exec( m[2] )\n                   ? [\"bulletlist\"]\n                   : [\"numberlist\"];\n\n          stack.push( { list: list, indent: m[1] } );\n          return list;\n        }\n\n\n        var stack = [], // Stack of lists for nesting.\n            list = make_list( m ),\n            last_li,\n            loose = false,\n            ret = [ stack[0].list ],\n            i;\n\n        // Loop to search over block looking for inner block elements and loose lists\n        loose_search:\n        while ( true ) {\n          // Split into lines preserving new lines at end of line\n          var lines = block.split( /(?=\\n)/ );\n\n          // We have to grab all lines for a li and call processInline on them\n          // once as there are some inline things that can span lines.\n          var li_accumulate = \"\";\n\n          // Loop over the lines in this block looking for tight lists.\n          tight_search:\n          for ( var line_no = 0; line_no < lines.length; line_no++ ) {\n            var nl = \"\",\n                l = lines[line_no].replace(/^\\n/, function(n) { nl = n; return \"\"; });\n\n            // TODO: really should cache this\n            var line_re = regex_for_depth( stack.length );\n\n            m = l.match( line_re );\n            //print( \"line:\", uneval(l), \"\\nline match:\", uneval(m) );\n\n            // We have a list item\n            if ( m[1] !== undefined ) {\n              // Process the previous list item, if any\n              if ( li_accumulate.length ) {\n                add( last_li, loose, this.processInline( li_accumulate ), nl );\n                // Loose mode will have been dealt with. Reset it\n                loose = false;\n                li_accumulate = \"\";\n              }\n\n              m[1] = expand_tab( m[1] );\n              var wanted_depth = Math.floor(m[1].length/4)+1;\n              //print( \"want:\", wanted_depth, \"stack:\", stack.length);\n              if ( wanted_depth > stack.length ) {\n                // Deep enough for a nested list outright\n                //print ( \"new nested list\" );\n                list = make_list( m );\n                last_li.push( list );\n                last_li = list[1] = [ \"listitem\" ];\n              }\n              else {\n                // We aren't deep enough to be strictly a new level. This is\n                // where Md.pl goes nuts. If the indent matches a level in the\n                // stack, put it there, else put it one deeper then the\n                // wanted_depth deserves.\n                var found = false;\n                for ( i = 0; i < stack.length; i++ ) {\n                  if ( stack[ i ].indent != m[1] ) continue;\n                  list = stack[ i ].list;\n                  stack.splice( i+1, stack.length - (i+1) );\n                  found = true;\n                  break;\n                }\n\n                if (!found) {\n                  //print(\"not found. l:\", uneval(l));\n                  wanted_depth++;\n                  if ( wanted_depth <= stack.length ) {\n                    stack.splice(wanted_depth, stack.length - wanted_depth);\n                    //print(\"Desired depth now\", wanted_depth, \"stack:\", stack.length);\n                    list = stack[wanted_depth-1].list;\n                    //print(\"list:\", uneval(list) );\n                  }\n                  else {\n                    //print (\"made new stack for messy indent\");\n                    list = make_list(m);\n                    last_li.push(list);\n                  }\n                }\n\n                //print( uneval(list), \"last\", list === stack[stack.length-1].list );\n                last_li = [ \"listitem\" ];\n                list.push(last_li);\n              } // end depth of shenegains\n              nl = \"\";\n            }\n\n            // Add content\n            if ( l.length > m[0].length ) {\n              li_accumulate += nl + l.substr( m[0].length );\n            }\n          } // tight_search\n\n          if ( li_accumulate.length ) {\n            add( last_li, loose, this.processInline( li_accumulate ), nl );\n            // Loose mode will have been dealt with. Reset it\n            loose = false;\n            li_accumulate = \"\";\n          }\n\n          // Look at the next block - we might have a loose list. Or an extra\n          // paragraph for the current li\n          var contained = get_contained_blocks( stack.length, next );\n\n          // Deal with code blocks or properly nested lists\n          if ( contained.length > 0 ) {\n            // Make sure all listitems up the stack are paragraphs\n            forEach( stack, paragraphify, this);\n\n            last_li.push.apply( last_li, this.toTree( contained, [] ) );\n          }\n\n          var next_block = next[0] && next[0].valueOf() || \"\";\n\n          if ( next_block.match(is_list_re) || next_block.match( /^ / ) ) {\n            block = next.shift();\n\n            // Check for an HR following a list: features/lists/hr_abutting\n            var hr = this.dialect.block.horizRule( block, next );\n\n            if ( hr ) {\n              ret.push.apply(ret, hr);\n              break;\n            }\n\n            // Make sure all listitems up the stack are paragraphs\n            forEach( stack, paragraphify, this);\n\n            loose = true;\n            continue loose_search;\n          }\n          break;\n        } // loose_search\n\n        return ret;\n      };\n    })(),\n\n    blockquote: function blockquote( block, next ) {\n      if ( !block.match( /^>/m ) )\n        return undefined;\n\n      var jsonml = [];\n\n      // separate out the leading abutting block, if any. I.e. in this case:\n      //\n      //  a\n      //  > b\n      //\n      if ( block[ 0 ] != \">\" ) {\n        var lines = block.split( /\\n/ ),\n            prev = [],\n            line_no = block.lineNumber;\n\n        // keep shifting lines until you find a crotchet\n        while ( lines.length && lines[ 0 ][ 0 ] != \">\" ) {\n            prev.push( lines.shift() );\n            line_no++;\n        }\n\n        var abutting = mk_block( prev.join( \"\\n\" ), \"\\n\", block.lineNumber );\n        jsonml.push.apply( jsonml, this.processBlock( abutting, [] ) );\n        // reassemble new block of just block quotes!\n        block = mk_block( lines.join( \"\\n\" ), block.trailing, line_no );\n      }\n\n\n      // if the next block is also a blockquote merge it in\n      while ( next.length && next[ 0 ][ 0 ] == \">\" ) {\n        var b = next.shift();\n        block = mk_block( block + block.trailing + b, b.trailing, block.lineNumber );\n      }\n\n      // Strip off the leading \"> \" and re-process as a block.\n      var input = block.replace( /^> ?/gm, \"\" ),\n          old_tree = this.tree,\n          processedBlock = this.toTree( input, [ \"blockquote\" ] ),\n          attr = extract_attr( processedBlock );\n\n      // If any link references were found get rid of them\n      if ( attr && attr.references ) {\n        delete attr.references;\n        // And then remove the attribute object if it's empty\n        if ( isEmpty( attr ) ) {\n          processedBlock.splice( 1, 1 );\n        }\n      }\n\n      jsonml.push( processedBlock );\n      return jsonml;\n    },\n\n    referenceDefn: function referenceDefn( block, next) {\n      var re = /^\\s*\\[(.*?)\\]:\\s*(\\S+)(?:\\s+(?:(['\"])(.*?)\\3|\\((.*?)\\)))?\\n?/;\n      // interesting matches are [ , ref_id, url, , title, title ]\n\n      if ( !block.match(re) )\n        return undefined;\n\n      // make an attribute node if it doesn't exist\n      if ( !extract_attr( this.tree ) ) {\n        this.tree.splice( 1, 0, {} );\n      }\n\n      var attrs = extract_attr( this.tree );\n\n      // make a references hash if it doesn't exist\n      if ( attrs.references === undefined ) {\n        attrs.references = {};\n      }\n\n      var b = this.loop_re_over_block(re, block, function( m ) {\n\n        if ( m[2] && m[2][0] == \"<\" && m[2][m[2].length-1] == \">\" )\n          m[2] = m[2].substring( 1, m[2].length - 1 );\n\n        var ref = attrs.references[ m[1].toLowerCase() ] = {\n          href: m[2]\n        };\n\n        if ( m[4] !== undefined )\n          ref.title = m[4];\n        else if ( m[5] !== undefined )\n          ref.title = m[5];\n\n      } );\n\n      if ( b.length )\n        next.unshift( mk_block( b, block.trailing ) );\n\n      return [];\n    },\n\n    para: function para( block, next ) {\n      // everything's a para!\n      return [ [\"para\"].concat( this.processInline( block ) ) ];\n    }\n  }\n};\n\nMarkdown.dialects.Gruber.inline = {\n\n    __oneElement__: function oneElement( text, patterns_or_re, previous_nodes ) {\n      var m,\n          res,\n          lastIndex = 0;\n\n      patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;\n      var re = new RegExp( \"([\\\\s\\\\S]*?)(\" + (patterns_or_re.source || patterns_or_re) + \")\" );\n\n      m = re.exec( text );\n      if (!m) {\n        // Just boring text\n        return [ text.length, text ];\n      }\n      else if ( m[1] ) {\n        // Some un-interesting text matched. Return that first\n        return [ m[1].length, m[1] ];\n      }\n\n      var res;\n      if ( m[2] in this.dialect.inline ) {\n        res = this.dialect.inline[ m[2] ].call(\n                  this,\n                  text.substr( m.index ), m, previous_nodes || [] );\n      }\n      // Default for now to make dev easier. just slurp special and output it.\n      res = res || [ m[2].length, m[2] ];\n      return res;\n    },\n\n    __call__: function inline( text, patterns ) {\n\n      var out = [],\n          res;\n\n      function add(x) {\n        //D:self.debug(\"  adding output\", uneval(x));\n        if ( typeof x == \"string\" && typeof out[out.length-1] == \"string\" )\n          out[ out.length-1 ] += x;\n        else\n          out.push(x);\n      }\n\n      while ( text.length > 0 ) {\n        res = this.dialect.inline.__oneElement__.call(this, text, patterns, out );\n        text = text.substr( res.shift() );\n        forEach(res, add )\n      }\n\n      return out;\n    },\n\n    // These characters are intersting elsewhere, so have rules for them so that\n    // chunks of plain text blocks don't include them\n    \"]\": function () {},\n    \"}\": function () {},\n\n    __escape__ : /^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-]/,\n\n    \"\\\\\": function escaped( text ) {\n      // [ length of input processed, node/children to add... ]\n      // Only esacape: \\ ` * _ { } [ ] ( ) # * + - . !\n      if ( this.dialect.inline.__escape__.exec( text ) )\n        return [ 2, text.charAt( 1 ) ];\n      else\n        // Not an esacpe\n        return [ 1, \"\\\\\" ];\n    },\n\n    \"![\": function image( text ) {\n\n      // Unlike images, alt text is plain text only. no other elements are\n      // allowed in there\n\n      // ![Alt text](/path/to/img.jpg \"Optional title\")\n      //      1          2            3       4         <--- captures\n      var m = text.match( /^!\\[(.*?)\\][ \\t]*\\([ \\t]*([^\")]*?)(?:[ \\t]+([\"'])(.*?)\\3)?[ \\t]*\\)/ );\n\n      if ( m ) {\n        if ( m[2] && m[2][0] == \"<\" && m[2][m[2].length-1] == \">\" )\n          m[2] = m[2].substring( 1, m[2].length - 1 );\n\n        m[2] = this.dialect.inline.__call__.call( this, m[2], /\\\\/ )[0];\n\n        var attrs = { alt: m[1], href: m[2] || \"\" };\n        if ( m[4] !== undefined)\n          attrs.title = m[4];\n\n        return [ m[0].length, [ \"img\", attrs ] ];\n      }\n\n      // ![Alt text][id]\n      m = text.match( /^!\\[(.*?)\\][ \\t]*\\[(.*?)\\]/ );\n\n      if ( m ) {\n        // We can't check if the reference is known here as it likely wont be\n        // found till after. Check it in md tree->hmtl tree conversion\n        return [ m[0].length, [ \"img_ref\", { alt: m[1], ref: m[2].toLowerCase(), original: m[0] } ] ];\n      }\n\n      // Just consume the '!['\n      return [ 2, \"![\" ];\n    },\n\n    \"[\": function link( text ) {\n\n      var orig = String(text);\n      // Inline content is possible inside `link text`\n      var res = Markdown.DialectHelpers.inline_until_char.call( this, text.substr(1), \"]\" );\n\n      // No closing ']' found. Just consume the [\n      if ( !res ) return [ 1, \"[\" ];\n\n      var consumed = 1 + res[ 0 ],\n          children = res[ 1 ],\n          link,\n          attrs;\n\n      // At this point the first [...] has been parsed. See what follows to find\n      // out which kind of link we are (reference or direct url)\n      text = text.substr( consumed );\n\n      // [link text](/path/to/img.jpg \"Optional title\")\n      //                 1            2       3         <--- captures\n      // This will capture up to the last paren in the block. We then pull\n      // back based on if there a matching ones in the url\n      //    ([here](/url/(test))\n      // The parens have to be balanced\n      var m = text.match( /^\\s*\\([ \\t]*([^\"']*)(?:[ \\t]+([\"'])(.*?)\\2)?[ \\t]*\\)/ );\n      if ( m ) {\n        var url = m[1];\n        consumed += m[0].length;\n\n        if ( url && url[0] == \"<\" && url[url.length-1] == \">\" )\n          url = url.substring( 1, url.length - 1 );\n\n        // If there is a title we don't have to worry about parens in the url\n        if ( !m[3] ) {\n          var open_parens = 1; // One open that isn't in the capture\n          for ( var len = 0; len < url.length; len++ ) {\n            switch ( url[len] ) {\n            case \"(\":\n              open_parens++;\n              break;\n            case \")\":\n              if ( --open_parens == 0) {\n                consumed -= url.length - len;\n                url = url.substring(0, len);\n              }\n              break;\n            }\n          }\n        }\n\n        // Process escapes only\n        url = this.dialect.inline.__call__.call( this, url, /\\\\/ )[0];\n\n        attrs = { href: url || \"\" };\n        if ( m[3] !== undefined)\n          attrs.title = m[3];\n\n        link = [ \"link\", attrs ].concat( children );\n        return [ consumed, link ];\n      }\n\n      // [Alt text][id]\n      // [Alt text] [id]\n      m = text.match( /^\\s*\\[(.*?)\\]/ );\n\n      if ( m ) {\n\n        consumed += m[ 0 ].length;\n\n        // [links][] uses links as its reference\n        attrs = { ref: ( m[ 1 ] || String(children) ).toLowerCase(),  original: orig.substr( 0, consumed ) };\n\n        link = [ \"link_ref\", attrs ].concat( children );\n\n        // We can't check if the reference is known here as it likely wont be\n        // found till after. Check it in md tree->hmtl tree conversion.\n        // Store the original so that conversion can revert if the ref isn't found.\n        return [ consumed, link ];\n      }\n\n      // [id]\n      // Only if id is plain (no formatting.)\n      if ( children.length == 1 && typeof children[0] == \"string\" ) {\n\n        attrs = { ref: children[0].toLowerCase(),  original: orig.substr( 0, consumed ) };\n        link = [ \"link_ref\", attrs, children[0] ];\n        return [ consumed, link ];\n      }\n\n      // Just consume the \"[\"\n      return [ 1, \"[\" ];\n    },\n\n\n    \"<\": function autoLink( text ) {\n      var m;\n\n      if ( ( m = text.match( /^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\\.[a-zA-Z]+))>/ ) ) != null ) {\n        if ( m[3] ) {\n          return [ m[0].length, [ \"link\", { href: \"mailto:\" + m[3] }, m[3] ] ];\n\n        }\n        else if ( m[2] == \"mailto\" ) {\n          return [ m[0].length, [ \"link\", { href: m[1] }, m[1].substr(\"mailto:\".length ) ] ];\n        }\n        else\n          return [ m[0].length, [ \"link\", { href: m[1] }, m[1] ] ];\n      }\n\n      return [ 1, \"<\" ];\n    },\n\n    \"`\": function inlineCode( text ) {\n      // Inline code block. as many backticks as you like to start it\n      // Always skip over the opening ticks.\n      var m = text.match( /(`+)(([\\s\\S]*?)\\1)/ );\n\n      if ( m && m[2] )\n        return [ m[1].length + m[2].length, [ \"inlinecode\", m[3] ] ];\n      else {\n        // TODO: No matching end code found - warn!\n        return [ 1, \"`\" ];\n      }\n    },\n\n    \"  \\n\": function lineBreak( text ) {\n      return [ 3, [ \"linebreak\" ] ];\n    }\n\n};\n\n// Meta Helper/generator method for em and strong handling\nfunction strong_em( tag, md ) {\n\n  var state_slot = tag + \"_state\",\n      other_slot = tag == \"strong\" ? \"em_state\" : \"strong_state\";\n\n  function CloseTag(len) {\n    this.len_after = len;\n    this.name = \"close_\" + md;\n  }\n\n  return function ( text, orig_match ) {\n\n    if ( this[state_slot][0] == md ) {\n      // Most recent em is of this type\n      //D:this.debug(\"closing\", md);\n      this[state_slot].shift();\n\n      // \"Consume\" everything to go back to the recrusion in the else-block below\n      return[ text.length, new CloseTag(text.length-md.length) ];\n    }\n    else {\n      // Store a clone of the em/strong states\n      var other = this[other_slot].slice(),\n          state = this[state_slot].slice();\n\n      this[state_slot].unshift(md);\n\n      //D:this.debug_indent += \"  \";\n\n      // Recurse\n      var res = this.processInline( text.substr( md.length ) );\n      //D:this.debug_indent = this.debug_indent.substr(2);\n\n      var last = res[res.length - 1];\n\n      //D:this.debug(\"processInline from\", tag + \": \", uneval( res ) );\n\n      var check = this[state_slot].shift();\n      if ( last instanceof CloseTag ) {\n        res.pop();\n        // We matched! Huzzah.\n        var consumed = text.length - last.len_after;\n        return [ consumed, [ tag ].concat(res) ];\n      }\n      else {\n        // Restore the state of the other kind. We might have mistakenly closed it.\n        this[other_slot] = other;\n        this[state_slot] = state;\n\n        // We can't reuse the processed result as it could have wrong parsing contexts in it.\n        return [ md.length, md ];\n      }\n    }\n  }; // End returned function\n}\n\nMarkdown.dialects.Gruber.inline[\"**\"] = strong_em(\"strong\", \"**\");\nMarkdown.dialects.Gruber.inline[\"__\"] = strong_em(\"strong\", \"__\");\nMarkdown.dialects.Gruber.inline[\"*\"]  = strong_em(\"em\", \"*\");\nMarkdown.dialects.Gruber.inline[\"_\"]  = strong_em(\"em\", \"_\");\n\n\n// Build default order from insertion order.\nMarkdown.buildBlockOrder = function(d) {\n  var ord = [];\n  for ( var i in d ) {\n    if ( i == \"__order__\" || i == \"__call__\" ) continue;\n    ord.push( i );\n  }\n  d.__order__ = ord;\n};\n\n// Build patterns for inline matcher\nMarkdown.buildInlinePatterns = function(d) {\n  var patterns = [];\n\n  for ( var i in d ) {\n    // __foo__ is reserved and not a pattern\n    if ( i.match( /^__.*__$/) ) continue;\n    var l = i.replace( /([\\\\.*+?|()\\[\\]{}])/g, \"\\\\$1\" )\n             .replace( /\\n/, \"\\\\n\" );\n    patterns.push( i.length == 1 ? l : \"(?:\" + l + \")\" );\n  }\n\n  patterns = patterns.join(\"|\");\n  d.__patterns__ = patterns;\n  //print(\"patterns:\", uneval( patterns ) );\n\n  var fn = d.__call__;\n  d.__call__ = function(text, pattern) {\n    if ( pattern != undefined ) {\n      return fn.call(this, text, pattern);\n    }\n    else\n    {\n      return fn.call(this, text, patterns);\n    }\n  };\n};\n\nMarkdown.DialectHelpers = {};\nMarkdown.DialectHelpers.inline_until_char = function( text, want ) {\n  var consumed = 0,\n      nodes = [];\n\n  while ( true ) {\n    if ( text.charAt( consumed ) == want ) {\n      // Found the character we were looking for\n      consumed++;\n      return [ consumed, nodes ];\n    }\n\n    if ( consumed >= text.length ) {\n      // No closing char found. Abort.\n      return null;\n    }\n\n    var res = this.dialect.inline.__oneElement__.call(this, text.substr( consumed ) );\n    consumed += res[ 0 ];\n    // Add any returned nodes.\n    nodes.push.apply( nodes, res.slice( 1 ) );\n  }\n}\n\n// Helper function to make sub-classing a dialect easier\nMarkdown.subclassDialect = function( d ) {\n  function Block() {}\n  Block.prototype = d.block;\n  function Inline() {}\n  Inline.prototype = d.inline;\n\n  return { block: new Block(), inline: new Inline() };\n};\n\nMarkdown.buildBlockOrder ( Markdown.dialects.Gruber.block );\nMarkdown.buildInlinePatterns( Markdown.dialects.Gruber.inline );\n\nMarkdown.dialects.Maruku = Markdown.subclassDialect( Markdown.dialects.Gruber );\n\nMarkdown.dialects.Maruku.processMetaHash = function processMetaHash( meta_string ) {\n  var meta = split_meta_hash( meta_string ),\n      attr = {};\n\n  for ( var i = 0; i < meta.length; ++i ) {\n    // id: #foo\n    if ( /^#/.test( meta[ i ] ) ) {\n      attr.id = meta[ i ].substring( 1 );\n    }\n    // class: .foo\n    else if ( /^\\./.test( meta[ i ] ) ) {\n      // if class already exists, append the new one\n      if ( attr[\"class\"] ) {\n        attr[\"class\"] = attr[\"class\"] + meta[ i ].replace( /./, \" \" );\n      }\n      else {\n        attr[\"class\"] = meta[ i ].substring( 1 );\n      }\n    }\n    // attribute: foo=bar\n    else if ( /\\=/.test( meta[ i ] ) ) {\n      var s = meta[ i ].split( /\\=/ );\n      attr[ s[ 0 ] ] = s[ 1 ];\n    }\n  }\n\n  return attr;\n}\n\nfunction split_meta_hash( meta_string ) {\n  var meta = meta_string.split( \"\" ),\n      parts = [ \"\" ],\n      in_quotes = false;\n\n  while ( meta.length ) {\n    var letter = meta.shift();\n    switch ( letter ) {\n      case \" \" :\n        // if we're in a quoted section, keep it\n        if ( in_quotes ) {\n          parts[ parts.length - 1 ] += letter;\n        }\n        // otherwise make a new part\n        else {\n          parts.push( \"\" );\n        }\n        break;\n      case \"'\" :\n      case '\"' :\n        // reverse the quotes and move straight on\n        in_quotes = !in_quotes;\n        break;\n      case \"\\\\\" :\n        // shift off the next letter to be used straight away.\n        // it was escaped so we'll keep it whatever it is\n        letter = meta.shift();\n      default :\n        parts[ parts.length - 1 ] += letter;\n        break;\n    }\n  }\n\n  return parts;\n}\n\nMarkdown.dialects.Maruku.block.document_meta = function document_meta( block, next ) {\n  // we're only interested in the first block\n  if ( block.lineNumber > 1 ) return undefined;\n\n  // document_meta blocks consist of one or more lines of `Key: Value\\n`\n  if ( ! block.match( /^(?:\\w+:.*\\n)*\\w+:.*$/ ) ) return undefined;\n\n  // make an attribute node if it doesn't exist\n  if ( !extract_attr( this.tree ) ) {\n    this.tree.splice( 1, 0, {} );\n  }\n\n  var pairs = block.split( /\\n/ );\n  for ( p in pairs ) {\n    var m = pairs[ p ].match( /(\\w+):\\s*(.*)$/ ),\n        key = m[ 1 ].toLowerCase(),\n        value = m[ 2 ];\n\n    this.tree[ 1 ][ key ] = value;\n  }\n\n  // document_meta produces no content!\n  return [];\n};\n\nMarkdown.dialects.Maruku.block.block_meta = function block_meta( block, next ) {\n  // check if the last line of the block is an meta hash\n  var m = block.match( /(^|\\n) {0,3}\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}$/ );\n  if ( !m ) return undefined;\n\n  // process the meta hash\n  var attr = this.dialect.processMetaHash( m[ 2 ] );\n\n  var hash;\n\n  // if we matched ^ then we need to apply meta to the previous block\n  if ( m[ 1 ] === \"\" ) {\n    var node = this.tree[ this.tree.length - 1 ];\n    hash = extract_attr( node );\n\n    // if the node is a string (rather than JsonML), bail\n    if ( typeof node === \"string\" ) return undefined;\n\n    // create the attribute hash if it doesn't exist\n    if ( !hash ) {\n      hash = {};\n      node.splice( 1, 0, hash );\n    }\n\n    // add the attributes in\n    for ( a in attr ) {\n      hash[ a ] = attr[ a ];\n    }\n\n    // return nothing so the meta hash is removed\n    return [];\n  }\n\n  // pull the meta hash off the block and process what's left\n  var b = block.replace( /\\n.*$/, \"\" ),\n      result = this.processBlock( b, [] );\n\n  // get or make the attributes hash\n  hash = extract_attr( result[ 0 ] );\n  if ( !hash ) {\n    hash = {};\n    result[ 0 ].splice( 1, 0, hash );\n  }\n\n  // attach the attributes to the block\n  for ( a in attr ) {\n    hash[ a ] = attr[ a ];\n  }\n\n  return result;\n};\n\nMarkdown.dialects.Maruku.block.definition_list = function definition_list( block, next ) {\n  // one or more terms followed by one or more definitions, in a single block\n  var tight = /^((?:[^\\s:].*\\n)+):\\s+([\\s\\S]+)$/,\n      list = [ \"dl\" ],\n      i, m;\n\n  // see if we're dealing with a tight or loose block\n  if ( ( m = block.match( tight ) ) ) {\n    // pull subsequent tight DL blocks out of `next`\n    var blocks = [ block ];\n    while ( next.length && tight.exec( next[ 0 ] ) ) {\n      blocks.push( next.shift() );\n    }\n\n    for ( var b = 0; b < blocks.length; ++b ) {\n      var m = blocks[ b ].match( tight ),\n          terms = m[ 1 ].replace( /\\n$/, \"\" ).split( /\\n/ ),\n          defns = m[ 2 ].split( /\\n:\\s+/ );\n\n      // print( uneval( m ) );\n\n      for ( i = 0; i < terms.length; ++i ) {\n        list.push( [ \"dt\", terms[ i ] ] );\n      }\n\n      for ( i = 0; i < defns.length; ++i ) {\n        // run inline processing over the definition\n        list.push( [ \"dd\" ].concat( this.processInline( defns[ i ].replace( /(\\n)\\s+/, \"$1\" ) ) ) );\n      }\n    }\n  }\n  else {\n    return undefined;\n  }\n\n  return [ list ];\n};\n\n// splits on unescaped instances of @ch. If @ch is not a character the result\n// can be unpredictable\n\nMarkdown.dialects.Maruku.block.table = function table (block, next) {\n\n    var _split_on_unescaped = function(s, ch) {\n        ch = ch || '\\\\s';\n        if (ch.match(/^[\\\\|\\[\\]{}?*.+^$]$/)) { ch = '\\\\' + ch; }\n        var res = [ ],\n            r = new RegExp('^((?:\\\\\\\\.|[^\\\\\\\\' + ch + '])*)' + ch + '(.*)'),\n            m;\n        while(m = s.match(r)) {\n            res.push(m[1]);\n            s = m[2];\n        }\n        res.push(s);\n        return res;\n    }\n\n    var leading_pipe = /^ {0,3}\\|(.+)\\n {0,3}\\|\\s*([\\-:]+[\\-| :]*)\\n((?:\\s*\\|.*(?:\\n|$))*)(?=\\n|$)/,\n        // find at least an unescaped pipe in each line\n        no_leading_pipe = /^ {0,3}(\\S(?:\\\\.|[^\\\\|])*\\|.*)\\n {0,3}([\\-:]+\\s*\\|[\\-| :]*)\\n((?:(?:\\\\.|[^\\\\|])*\\|.*(?:\\n|$))*)(?=\\n|$)/,\n        i, m;\n    if (m = block.match(leading_pipe)) {\n        // remove leading pipes in contents\n        // (header and horizontal rule already have the leading pipe left out)\n        m[3] = m[3].replace(/^\\s*\\|/gm, '');\n    } else if (! ( m = block.match(no_leading_pipe))) {\n        return undefined;\n    }\n\n    var table = [ \"table\", [ \"thead\", [ \"tr\" ] ], [ \"tbody\" ] ];\n\n    // remove trailing pipes, then split on pipes\n    // (no escaped pipes are allowed in horizontal rule)\n    m[2] = m[2].replace(/\\|\\s*$/, '').split('|');\n\n    // process alignment\n    var html_attrs = [ ];\n    forEach (m[2], function (s) {\n        if (s.match(/^\\s*-+:\\s*$/))       html_attrs.push({align: \"right\"});\n        else if (s.match(/^\\s*:-+\\s*$/))  html_attrs.push({align: \"left\"});\n        else if (s.match(/^\\s*:-+:\\s*$/)) html_attrs.push({align: \"center\"});\n        else                              html_attrs.push({});\n    });\n\n    // now for the header, avoid escaped pipes\n    m[1] = _split_on_unescaped(m[1].replace(/\\|\\s*$/, ''), '|');\n    for (i = 0; i < m[1].length; i++) {\n        table[1][1].push(['th', html_attrs[i] || {}].concat(\n            this.processInline(m[1][i].trim())));\n    }\n\n    // now for body contents\n    forEach (m[3].replace(/\\|\\s*$/mg, '').split('\\n'), function (row) {\n        var html_row = ['tr'];\n        row = _split_on_unescaped(row, '|');\n        for (i = 0; i < row.length; i++) {\n            html_row.push(['td', html_attrs[i] || {}].concat(this.processInline(row[i].trim())));\n        }\n        table[2].push(html_row);\n    }, this);\n\n    return [table];\n}\n\nMarkdown.dialects.Maruku.inline[ \"{:\" ] = function inline_meta( text, matches, out ) {\n  if ( !out.length ) {\n    return [ 2, \"{:\" ];\n  }\n\n  // get the preceeding element\n  var before = out[ out.length - 1 ];\n\n  if ( typeof before === \"string\" ) {\n    return [ 2, \"{:\" ];\n  }\n\n  // match a meta hash\n  var m = text.match( /^\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}/ );\n\n  // no match, false alarm\n  if ( !m ) {\n    return [ 2, \"{:\" ];\n  }\n\n  // attach the attributes to the preceeding element\n  var meta = this.dialect.processMetaHash( m[ 1 ] ),\n      attr = extract_attr( before );\n\n  if ( !attr ) {\n    attr = {};\n    before.splice( 1, 0, attr );\n  }\n\n  for ( var k in meta ) {\n    attr[ k ] = meta[ k ];\n  }\n\n  // cut out the string and replace it with nothing\n  return [ m[ 0 ].length, \"\" ];\n};\n\nMarkdown.dialects.Maruku.inline.__escape__ = /^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-|:]/;\n\nMarkdown.buildBlockOrder ( Markdown.dialects.Maruku.block );\nMarkdown.buildInlinePatterns( Markdown.dialects.Maruku.inline );\n\nvar isArray = Array.isArray || function(obj) {\n  return Object.prototype.toString.call(obj) == \"[object Array]\";\n};\n\nvar forEach;\n// Don't mess with Array.prototype. Its not friendly\nif ( Array.prototype.forEach ) {\n  forEach = function( arr, cb, thisp ) {\n    return arr.forEach( cb, thisp );\n  };\n}\nelse {\n  forEach = function(arr, cb, thisp) {\n    for (var i = 0; i < arr.length; i++) {\n      cb.call(thisp || arr, arr[i], i, arr);\n    }\n  }\n}\n\nvar isEmpty = function( obj ) {\n  for ( var key in obj ) {\n    if ( hasOwnProperty.call( obj, key ) ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction extract_attr( jsonml ) {\n  return isArray(jsonml)\n      && jsonml.length > 1\n      && typeof jsonml[ 1 ] === \"object\"\n      && !( isArray(jsonml[ 1 ]) )\n      ? jsonml[ 1 ]\n      : undefined;\n}\n\n\n\n/**\n *  renderJsonML( jsonml[, options] ) -> String\n *  - jsonml (Array): JsonML array to render to XML\n *  - options (Object): options\n *\n *  Converts the given JsonML into well-formed XML.\n *\n *  The options currently understood are:\n *\n *  - root (Boolean): wether or not the root node should be included in the\n *    output, or just its children. The default `false` is to not include the\n *    root itself.\n */\nexpose.renderJsonML = function( jsonml, options ) {\n  options = options || {};\n  // include the root element in the rendered output?\n  options.root = options.root || false;\n\n  var content = [];\n\n  if ( options.root ) {\n    content.push( render_tree( jsonml ) );\n  }\n  else {\n    jsonml.shift(); // get rid of the tag\n    if ( jsonml.length && typeof jsonml[ 0 ] === \"object\" && !( jsonml[ 0 ] instanceof Array ) ) {\n      jsonml.shift(); // get rid of the attributes\n    }\n\n    while ( jsonml.length ) {\n      content.push( render_tree( jsonml.shift() ) );\n    }\n  }\n\n  return content.join( \"\\n\\n\" );\n};\n\nfunction escapeHTML( text ) {\n  return text.replace( /&/g, \"&amp;\" )\n             .replace( /</g, \"&lt;\" )\n             .replace( />/g, \"&gt;\" )\n             .replace( /\"/g, \"&quot;\" )\n             .replace( /'/g, \"&#39;\" );\n}\n\nfunction render_tree( jsonml ) {\n  // basic case\n  if ( typeof jsonml === \"string\" ) {\n    return escapeHTML( jsonml );\n  }\n\n  var tag = jsonml.shift(),\n      attributes = {},\n      content = [];\n\n  if ( jsonml.length && typeof jsonml[ 0 ] === \"object\" && !( jsonml[ 0 ] instanceof Array ) ) {\n    attributes = jsonml.shift();\n  }\n\n  while ( jsonml.length ) {\n    content.push( render_tree( jsonml.shift() ) );\n  }\n\n  var tag_attrs = \"\";\n  for ( var a in attributes ) {\n    tag_attrs += \" \" + a + '=\"' + escapeHTML( attributes[ a ] ) + '\"';\n  }\n\n  // be careful about adding whitespace here for inline elements\n  if ( tag == \"img\" || tag == \"br\" || tag == \"hr\" ) {\n    return \"<\"+ tag + tag_attrs + \"/>\";\n  }\n  else {\n    return \"<\"+ tag + tag_attrs + \">\" + content.join( \"\" ) + \"</\" + tag + \">\";\n  }\n}\n\nfunction convert_tree_to_html( tree, references, options ) {\n  var i;\n  options = options || {};\n\n  // shallow clone\n  var jsonml = tree.slice( 0 );\n\n  if ( typeof options.preprocessTreeNode === \"function\" ) {\n      jsonml = options.preprocessTreeNode(jsonml, references);\n  }\n\n  // Clone attributes if they exist\n  var attrs = extract_attr( jsonml );\n  if ( attrs ) {\n    jsonml[ 1 ] = {};\n    for ( i in attrs ) {\n      jsonml[ 1 ][ i ] = attrs[ i ];\n    }\n    attrs = jsonml[ 1 ];\n  }\n\n  // basic case\n  if ( typeof jsonml === \"string\" ) {\n    return jsonml;\n  }\n\n  // convert this node\n  switch ( jsonml[ 0 ] ) {\n    case \"header\":\n      jsonml[ 0 ] = \"h\" + jsonml[ 1 ].level;\n      delete jsonml[ 1 ].level;\n      break;\n    case \"bulletlist\":\n      jsonml[ 0 ] = \"ul\";\n      break;\n    case \"numberlist\":\n      jsonml[ 0 ] = \"ol\";\n      break;\n    case \"listitem\":\n      jsonml[ 0 ] = \"li\";\n      break;\n    case \"para\":\n      jsonml[ 0 ] = \"p\";\n      break;\n    case \"markdown\":\n      jsonml[ 0 ] = \"html\";\n      if ( attrs ) delete attrs.references;\n      break;\n    case \"code_block\":\n      jsonml[ 0 ] = \"pre\";\n      i = attrs ? 2 : 1;\n      var code = [ \"code\" ];\n      code.push.apply( code, jsonml.splice( i, jsonml.length - i ) );\n      jsonml[ i ] = code;\n      break;\n    case \"inlinecode\":\n      jsonml[ 0 ] = \"code\";\n      break;\n    case \"img\":\n      jsonml[ 1 ].src = jsonml[ 1 ].href;\n      delete jsonml[ 1 ].href;\n      break;\n    case \"linebreak\":\n      jsonml[ 0 ] = \"br\";\n    break;\n    case \"link\":\n      jsonml[ 0 ] = \"a\";\n      break;\n    case \"link_ref\":\n      jsonml[ 0 ] = \"a\";\n\n      // grab this ref and clean up the attribute node\n      var ref = references[ attrs.ref ];\n\n      // if the reference exists, make the link\n      if ( ref ) {\n        delete attrs.ref;\n\n        // add in the href and title, if present\n        attrs.href = ref.href;\n        if ( ref.title ) {\n          attrs.title = ref.title;\n        }\n\n        // get rid of the unneeded original text\n        delete attrs.original;\n      }\n      // the reference doesn't exist, so revert to plain text\n      else {\n        return attrs.original;\n      }\n      break;\n    case \"img_ref\":\n      jsonml[ 0 ] = \"img\";\n\n      // grab this ref and clean up the attribute node\n      var ref = references[ attrs.ref ];\n\n      // if the reference exists, make the link\n      if ( ref ) {\n        delete attrs.ref;\n\n        // add in the href and title, if present\n        attrs.src = ref.href;\n        if ( ref.title ) {\n          attrs.title = ref.title;\n        }\n\n        // get rid of the unneeded original text\n        delete attrs.original;\n      }\n      // the reference doesn't exist, so revert to plain text\n      else {\n        return attrs.original;\n      }\n      break;\n  }\n\n  // convert all the children\n  i = 1;\n\n  // deal with the attribute node, if it exists\n  if ( attrs ) {\n    // if there are keys, skip over it\n    for ( var key in jsonml[ 1 ] ) {\n        i = 2;\n        break;\n    }\n    // if there aren't, remove it\n    if ( i === 1 ) {\n      jsonml.splice( i, 1 );\n    }\n  }\n\n  for ( ; i < jsonml.length; ++i ) {\n    jsonml[ i ] = convert_tree_to_html( jsonml[ i ], references, options );\n  }\n\n  return jsonml;\n}\n\n\n// merges adjacent text nodes into a single node\nfunction merge_text_nodes( jsonml ) {\n  // skip the tag name and attribute hash\n  var i = extract_attr( jsonml ) ? 2 : 1;\n\n  while ( i < jsonml.length ) {\n    // if it's a string check the next item too\n    if ( typeof jsonml[ i ] === \"string\" ) {\n      if ( i + 1 < jsonml.length && typeof jsonml[ i + 1 ] === \"string\" ) {\n        // merge the second string into the first and remove it\n        jsonml[ i ] += jsonml.splice( i + 1, 1 )[ 0 ];\n      }\n      else {\n        ++i;\n      }\n    }\n    // if it's not a string recurse\n    else {\n      merge_text_nodes( jsonml[ i ] );\n      ++i;\n    }\n  }\n}\n\n} )( (function() {\n  if ( typeof exports === \"undefined\" ) {\n    window.markdown = {};\n    return window.markdown;\n  }\n  else {\n    return exports;\n  }\n} )() );\n","// super simple module for the most common nodejs use case.\nexports.markdown = require(\"./markdown\");\nexports.parse = exports.markdown.toHTML;\n","\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/markdown-to-html\",\n      function () {\n        return require(\"private-next-pages/markdown-to-html.tsx\");\n      }\n    ]);\n  "]}}