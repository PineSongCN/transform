{"code":"(\"object\"!==typeof self?self:this.webpackJsonp_N_E=\"object\"!==typeof self?self:this.webpackJsonp_N_E||[]).push([[11],{\"2nTQ\":function(e,t,r){\"use strict\";(function(e){r.d(t,\"a\",(function(){return d}));var n=r(\"dKrm\");let i=0,o=null;function s(){return null!==o&&o.buffer===n.e.buffer||(o=new Uint8Array(n.e.buffer)),o}let f=new(\"undefined\"===typeof TextEncoder?(0,e.require)(\"util\").TextEncoder:TextEncoder)(\"utf-8\");if(!window.TextEncoder){const e=r(\"tLY0\");window.TextEncoder=e.TextEncoder,window.TextDecoder=e.TextDecoder}const u=\"function\"===typeof f.encodeInto?function(e,t){return f.encodeInto(e,t)}:function(e,t){const r=f.encode(e);return t.set(r),{read:e.length,written:r.length}};function a(e,t,r){if(void 0===r){const r=f.encode(e),n=t(r.length);return s().subarray(n,n+r.length).set(r),i=r.length,n}let n=e.length,o=t(n);const a=s();let c=0;for(;c<n;c++){const t=e.charCodeAt(c);if(t>127)break;a[o+c]=t}if(c!==n){0!==c&&(e=e.slice(c)),o=r(o,n,n=c+3*e.length);const t=s().subarray(o+c,o+n);c+=u(e,t).written}return i=c,o}let c=null;function h(){return null!==c&&c.buffer===n.e.buffer||(c=new Int32Array(n.e.buffer)),c}let l=new(\"undefined\"===typeof TextDecoder?(0,e.require)(\"util\").TextDecoder:TextDecoder)(\"utf-8\",{ignoreBOM:!0,fatal:!0});function d(e,t,r){try{const v=n.a(-16);var o=a(e,n.c,n.d),f=i,u=a(t,n.c,n.d),c=i,d=a(r,n.c,n.d),p=i;n.f(v,o,f,u,c,d,p);var y=h()[v/4+0],g=h()[v/4+1];return _=y,w=g,l.decode(s().subarray(_,_+w))}finally{n.a(16),n.b(y,g)}var _,w}l.decode()}).call(this,r(\"Az8m\")(e))},P0Z9:function(e,t,r){\"use strict\";r.r(t);var n=r(\"2nTQ\");r.d(t,\"run\",(function(){return n.a}))},tLY0:function(e,t,r){\"use strict\";function n(e,t,r){return t<=e&&e<=r}function i(e){if(void 0===e)return{};if(e===Object(e))return e;throw TypeError(\"Could not convert argument to dictionary\")}r.r(t),r.d(t,\"TextEncoder\",(function(){return c})),r.d(t,\"TextDecoder\",(function(){return a}));function o(e){this.tokens=[].slice.call(e)}o.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():-1},prepend:function(e){if(Array.isArray(e))for(var t=e;t.length;)this.tokens.unshift(t.pop());else this.tokens.unshift(e)},push:function(e){if(Array.isArray(e))for(var t=e;t.length;)this.tokens.push(t.shift());else this.tokens.push(e)}};var s=-1;function f(e,t){if(e)throw TypeError(\"Decoder error\");return t||65533}var u=\"utf-8\";function a(e,t){if(!(this instanceof a))return new a(e,t);if((e=void 0!==e?String(e).toLowerCase():u)!==u)throw new Error(\"Encoding not supported. Only utf-8 is supported\");t=i(t),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=Boolean(t.fatal),this._ignoreBOM=Boolean(t.ignoreBOM),Object.defineProperty(this,\"encoding\",{value:\"utf-8\"}),Object.defineProperty(this,\"fatal\",{value:this._fatal}),Object.defineProperty(this,\"ignoreBOM\",{value:this._ignoreBOM})}function c(e,t){if(!(this instanceof c))return new c(e,t);if((e=void 0!==e?String(e).toLowerCase():u)!==u)throw new Error(\"Encoding not supported. Only utf-8 is supported\");t=i(t),this._streaming=!1,this._encoder=null,this._options={fatal:Boolean(t.fatal)},Object.defineProperty(this,\"encoding\",{value:\"utf-8\"})}function h(e){var t=e.fatal,r=0,i=0,o=0,u=128,a=191;this.handler=function(e,c){if(-1===c&&0!==o)return o=0,f(t);if(-1===c)return s;if(0===o){if(n(c,0,127))return c;if(n(c,194,223))o=1,r=c-192;else if(n(c,224,239))224===c&&(u=160),237===c&&(a=159),o=2,r=c-224;else{if(!n(c,240,244))return f(t);240===c&&(u=144),244===c&&(a=143),o=3,r=c-240}return r<<=6*o,null}if(!n(c,u,a))return r=o=i=0,u=128,a=191,e.prepend(c),f(t);if(u=128,a=191,r+=c-128<<6*(o-(i+=1)),i!==o)return null;var h=r;return r=o=i=0,h}}function l(e){e.fatal;this.handler=function(e,t){if(-1===t)return s;if(n(t,0,127))return t;var r,i;n(t,128,2047)?(r=1,i=192):n(t,2048,65535)?(r=2,i=224):n(t,65536,1114111)&&(r=3,i=240);for(var o=[(t>>6*r)+i];r>0;){var f=t>>6*(r-1);o.push(128|63&f),r-=1}return o}}a.prototype={decode:function(e,t){var r;r=\"object\"===typeof e&&e instanceof ArrayBuffer?new Uint8Array(e):\"object\"===typeof e&&\"buffer\"in e&&e.buffer instanceof ArrayBuffer?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):new Uint8Array(0),t=i(t),this._streaming||(this._decoder=new h({fatal:this._fatal}),this._BOMseen=!1),this._streaming=Boolean(t.stream);for(var n,f=new o(r),u=[];!f.endOfStream()&&(n=this._decoder.handler(f,f.read()))!==s;)null!==n&&(Array.isArray(n)?u.push.apply(u,n):u.push(n));if(!this._streaming){do{if((n=this._decoder.handler(f,f.read()))===s)break;null!==n&&(Array.isArray(n)?u.push.apply(u,n):u.push(n))}while(!f.endOfStream());this._decoder=null}return u.length&&(-1===[\"utf-8\"].indexOf(this.encoding)||this._ignoreBOM||this._BOMseen||(65279===u[0]?(this._BOMseen=!0,u.shift()):this._BOMseen=!0)),function(e){for(var t=\"\",r=0;r<e.length;++r){var n=e[r];n<=65535?t+=String.fromCharCode(n):(n-=65536,t+=String.fromCharCode(55296+(n>>10),56320+(1023&n)))}return t}(u)}},c.prototype={encode:function(e,t){e=e?String(e):\"\",t=i(t),this._streaming||(this._encoder=new l(this._options)),this._streaming=Boolean(t.stream);for(var r,n=[],f=new o(function(e){for(var t=String(e),r=t.length,n=0,i=[];n<r;){var o=t.charCodeAt(n);if(o<55296||o>57343)i.push(o);else if(56320<=o&&o<=57343)i.push(65533);else if(55296<=o&&o<=56319)if(n===r-1)i.push(65533);else{var s=e.charCodeAt(n+1);if(56320<=s&&s<=57343){var f=1023&o,u=1023&s;i.push(65536+(f<<10)+u),n+=1}else i.push(65533)}n+=1}return i}(e));!f.endOfStream()&&(r=this._encoder.handler(f,f.read()))!==s;)Array.isArray(r)?n.push.apply(n,r):n.push(r);if(!this._streaming){for(;(r=this._encoder.handler(f,f.read()))!==s;)Array.isArray(r)?n.push.apply(n,r):n.push(r);this._encoder=null}return new Uint8Array(n)}}}}]);","map":{"version":3,"sources":["static/chunks/11.63d91a55fdd53a876cdf.js"],"names":["self","this","push","2nTQ","module","__webpack_exports__","__webpack_require__","d","run","_json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__","WASM_VECTOR_LEN","cachegetUint8Memory0","getUint8Memory0","buffer","Uint8Array","cachedTextEncoder","TextEncoder","require","window","encoding","TextDecoder","encodeString","encodeInto","arg","view","buf","encode","set","read","length","written","passStringToWasm0","malloc","realloc","undefined","ptr","subarray","len","mem","offset","code","charCodeAt","slice","cachegetInt32Memory0","getInt32Memory0","Int32Array","cachedTextDecoder","ignoreBOM","fatal","name","input","options","retptr","ptr0","len0","ptr1","len1","ptr2","len2","r0","r1","decode","call","P0Z9","r","_json_typegen_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__","tLY0","__webpack_module__","inRange","a","min","max","ToDictionary","o","Object","TypeError","Stream","tokens","prototype","endOfStream","shift","prepend","token","Array","isArray","unshift","pop","finished","decoderError","opt_code_point","DEFAULT_ENCODING","String","toLowerCase","Error","_streaming","_BOMseen","_decoder","_fatal","Boolean","_ignoreBOM","defineProperty","value","_encoder","_options","UTF8Decoder","utf8_code_point","utf8_bytes_seen","utf8_bytes_needed","utf8_lower_boundary","utf8_upper_boundary","handler","stream","bite","code_point","UTF8Encoder","count","bytes","temp","ArrayBuffer","byteOffset","byteLength","result","input_stream","code_points","apply","indexOf","s","i","cp","fromCharCode","codePointsToString","opt_string","string","n","u","c","b","stringToCodePoints"],"mappings":"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"},"name":"static/chunks/11.63d91a55fdd53a876cdf.js","input":"(typeof self !== \"object\" ? self : this[\"webpackJsonp_N_E\"] = typeof self !== \"object\" ? self : this[\"webpackJsonp_N_E\"] || []).push([[11],{\n\n/***/ \"2nTQ\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return run; });\n/* harmony import */ var _json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"dKrm\");\n\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== _json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[/* memory */ \"e\"].buffer) {\n        cachegetUint8Memory0 = new Uint8Array(_json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[/* memory */ \"e\"].buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nif ( true && !window.TextEncoder) {\n        const encoding = __webpack_require__(\"tLY0\");\n        window.TextEncoder = encoding.TextEncoder;\n        window.TextDecoder = encoding.TextDecoder;\n    }\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== _json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[/* memory */ \"e\"].buffer) {\n        cachegetInt32Memory0 = new Int32Array(_json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[/* memory */ \"e\"].buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @param {string} name\n* @param {string} input\n* @param {string} options\n* @returns {string}\n*/\nfunction run(name, input, options) {\n    try {\n        const retptr = _json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[/* __wbindgen_add_to_stack_pointer */ \"a\"](-16);\n        var ptr0 = passStringToWasm0(name, _json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[/* __wbindgen_malloc */ \"c\"], _json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[/* __wbindgen_realloc */ \"d\"]);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(input, _json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[/* __wbindgen_malloc */ \"c\"], _json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[/* __wbindgen_realloc */ \"d\"]);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = passStringToWasm0(options, _json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[/* __wbindgen_malloc */ \"c\"], _json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[/* __wbindgen_realloc */ \"d\"]);\n        var len2 = WASM_VECTOR_LEN;\n        _json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[/* run */ \"f\"](retptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        _json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[/* __wbindgen_add_to_stack_pointer */ \"a\"](16);\n        _json_typegen_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[/* __wbindgen_free */ \"b\"](r0, r1);\n    }\n}\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"Az8m\")(module)))\n\n/***/ }),\n\n/***/ \"P0Z9\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _json_typegen_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"2nTQ\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"run\", function() { return _json_typegen_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"]; });\n\n\n\n\n/***/ }),\n\n/***/ \"tLY0\":\n/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextEncoder\", function() { return TextEncoder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextDecoder\", function() { return TextDecoder; });\n\n\n// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n//\n// Utilities\n//\n\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n/**\n * @param {*} o\n * @return {Object}\n */\nfunction ToDictionary(o) {\n  if (o === undefined) return {};\n  if (o === Object(o)) return o;\n  throw TypeError('Could not convert argument to dictionary');\n}\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nfunction stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string);\n\n  // 2. Let n be the length of S.\n  var n = s.length;\n\n  // 3. Initialize i to 0.\n  var i = 0;\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = [];\n\n  // 5. While i < n:\n  while (i < n) {\n\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i);\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xD800 || c > 0xDFFF) {\n      // Append to U the Unicode character with code point c.\n      u.push(c);\n    }\n\n    // 0xDC00 ≤ c ≤ 0xDFFF\n    else if (0xDC00 <= c && c <= 0xDFFF) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xFFFD);\n    }\n\n    // 0xD800 ≤ c ≤ 0xDBFF\n    else if (0xD800 <= c && c <= 0xDBFF) {\n      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xFFFD);\n      }\n      // 2. Otherwise, i < n−1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = string.charCodeAt(i + 1);\n\n        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n        if (0xDC00 <= d && d <= 0xDFFF) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3FF;\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3FF;\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b);\n\n          // 4. Set i to i+1.\n          i += 1;\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else  {\n          u.push(0xFFFD);\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1;\n  }\n\n  // 6. Return U.\n  return u;\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nfunction codePointsToString(code_points) {\n  var s = '';\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i];\n    if (cp <= 0xFFFF) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xD800,\n                               (cp & 0x3FF) + 0xDC00);\n    }\n  }\n  return s;\n}\n\n\n//\n// Implementation of Encoding specification\n// https://encoding.spec.whatwg.org/\n//\n\n//\n// 3. Terminology\n//\n\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n * @const\n */ var end_of_stream = -1;\n\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the\n * stream.\n */\nfunction Stream(tokens) {\n  /** @type {!Array.<number>} */\n  this.tokens = [].slice.call(tokens);\n}\n\nStream.prototype = {\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream: function() {\n    return !this.tokens.length;\n  },\n\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n   read: function() {\n    if (!this.tokens.length)\n      return end_of_stream;\n     return this.tokens.shift();\n   },\n\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.\n   */\n  prepend: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.unshift(tokens.pop());\n    } else {\n      this.tokens.unshift(token);\n    }\n  },\n\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.\n   */\n  push: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.push(tokens.shift());\n    } else {\n      this.tokens.push(token);\n    }\n  }\n};\n\n//\n// 4. Encodings\n//\n\n// 4.1 Encoders and decoders\n\n/** @const */\nvar finished = -1;\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return {number} The code point to insert on a decoding error.\n */\nfunction decoderError(fatal, opt_code_point) {\n  if (fatal)\n    throw TypeError('Decoder error');\n  return opt_code_point || 0xFFFD;\n}\n\n/** @interface */\nfunction Decoder() {}\nDecoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point, or |finished|.\n   */\n  handler: function(stream, bite) {}\n};\n\n/** @interface */\nfunction Encoder() {}\nEncoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of code points being encoded.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n   */\n  handler: function(stream, code_point) {}\n};\n\n//\n// 7. API\n//\n\n/** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n// 7.1 Interface TextDecoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextDecoder(encoding, options) {\n  if (!(this instanceof TextDecoder)) {\n    return new TextDecoder(encoding, options);\n  }\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {boolean} */\n  this._BOMseen = false;\n  /** @private @type {?Decoder} */\n  this._decoder = null;\n  /** @private @type {boolean} */\n  this._fatal = Boolean(options['fatal']);\n  /** @private @type {boolean} */\n  this._ignoreBOM = Boolean(options['ignoreBOM']);\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n  Object.defineProperty(this, 'fatal', {value: this._fatal});\n  Object.defineProperty(this, 'ignoreBOM', {value: this._ignoreBOM});\n}\n\nTextDecoder.prototype = {\n  /**\n   * @param {ArrayBufferView=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  decode: function decode(input, options) {\n    var bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input &&\n               input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n                             input.byteOffset,\n                             input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options);\n\n    if (!this._streaming) {\n      this._decoder = new UTF8Decoder({fatal: this._fatal});\n      this._BOMseen = false;\n    }\n    this._streaming = Boolean(options['stream']);\n\n    var input_stream = new Stream(bytes);\n\n    var code_points = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n\n    while (!input_stream.endOfStream()) {\n      result = this._decoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (result === null)\n        continue;\n      if (Array.isArray(result))\n        code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n      else\n        code_points.push(result);\n    }\n    if (!this._streaming) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (result === null)\n          continue;\n        if (Array.isArray(result))\n          code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n        else\n          code_points.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    if (code_points.length) {\n      // If encoding is one of utf-8, utf-16be, and utf-16le, and\n      // ignore BOM flag and BOM seen flag are unset, run these\n      // subsubsteps:\n      if (['utf-8'].indexOf(this.encoding) !== -1 &&\n          !this._ignoreBOM && !this._BOMseen) {\n        // If token is U+FEFF, set BOM seen flag.\n        if (code_points[0] === 0xFEFF) {\n          this._BOMseen = true;\n          code_points.shift();\n        } else {\n          // Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to output.\n          this._BOMseen = true;\n        }\n      }\n    }\n\n    return codePointsToString(code_points);\n  }\n};\n\n// 7.2 Interface TextEncoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextEncoder(encoding, options) {\n  if (!(this instanceof TextEncoder))\n    return new TextEncoder(encoding, options);\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {?Encoder} */\n  this._encoder = null;\n  /** @private @type {{fatal: boolean}} */\n  this._options = {fatal: Boolean(options['fatal'])};\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n}\n\nTextEncoder.prototype = {\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  encode: function encode(opt_string, options) {\n    opt_string = opt_string ? String(opt_string) : '';\n    options = ToDictionary(options);\n\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,\n    // so streaming is not necessary.\n    if (!this._streaming)\n      this._encoder = new UTF8Encoder(this._options);\n    this._streaming = Boolean(options['stream']);\n\n    var bytes = [];\n    var input_stream = new Stream(stringToCodePoints(opt_string));\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n    while (!input_stream.endOfStream()) {\n      result = this._encoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (Array.isArray(result))\n        bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n      else\n        bytes.push(result);\n    }\n    if (!this._streaming) {\n      while (true) {\n        result = this._encoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (Array.isArray(result))\n          bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n        else\n          bytes.push(result);\n      }\n      this._encoder = null;\n    }\n    return new Uint8Array(bytes);\n  }\n};\n\n//\n// 8. The encoding\n//\n\n// 8.1 utf-8\n\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Decoder(options) {\n  var fatal = options.fatal;\n\n  // utf-8's decoder's has an associated utf-8 code point, utf-8\n  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n  // lower boundary (initially 0x80), and a utf-8 upper boundary\n  // (initially 0xBF).\n  var /** @type {number} */ utf8_code_point = 0,\n      /** @type {number} */ utf8_bytes_seen = 0,\n      /** @type {number} */ utf8_bytes_needed = 0,\n      /** @type {number} */ utf8_lower_boundary = 0x80,\n      /** @type {number} */ utf8_upper_boundary = 0xBF;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n    // set utf-8 bytes needed to 0 and return error.\n    if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n      utf8_bytes_needed = 0;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream)\n      return finished;\n\n    // 3. If utf-8 bytes needed is 0, based on byte:\n    if (utf8_bytes_needed === 0) {\n\n      // 0x00 to 0x7F\n      if (inRange(bite, 0x00, 0x7F)) {\n        // Return a code point whose value is byte.\n        return bite;\n      }\n\n      // 0xC2 to 0xDF\n      if (inRange(bite, 0xC2, 0xDF)) {\n        // Set utf-8 bytes needed to 1 and utf-8 code point to byte\n        // − 0xC0.\n        utf8_bytes_needed = 1;\n        utf8_code_point = bite - 0xC0;\n      }\n\n      // 0xE0 to 0xEF\n      else if (inRange(bite, 0xE0, 0xEF)) {\n        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (bite === 0xE0)\n          utf8_lower_boundary = 0xA0;\n        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (bite === 0xED)\n          utf8_upper_boundary = 0x9F;\n        // 3. Set utf-8 bytes needed to 2 and utf-8 code point to\n        // byte − 0xE0.\n        utf8_bytes_needed = 2;\n        utf8_code_point = bite - 0xE0;\n      }\n\n      // 0xF0 to 0xF4\n      else if (inRange(bite, 0xF0, 0xF4)) {\n        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (bite === 0xF0)\n          utf8_lower_boundary = 0x90;\n        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (bite === 0xF4)\n          utf8_upper_boundary = 0x8F;\n        // 3. Set utf-8 bytes needed to 3 and utf-8 code point to\n        // byte − 0xF0.\n        utf8_bytes_needed = 3;\n        utf8_code_point = bite - 0xF0;\n      }\n\n      // Otherwise\n      else {\n        // Return error.\n        return decoderError(fatal);\n      }\n\n      // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code\n      // point to utf-8 code point << (6 × utf-8 bytes needed) and\n      // return continue.\n      utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);\n      return null;\n    }\n\n    // 4. If byte is not in the range utf-8 lower boundary to utf-8\n    // upper boundary, run these substeps:\n    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n\n      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n      // utf-8 upper boundary to 0xBF.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite);\n\n      // 3. Return error.\n      return decoderError(fatal);\n    }\n\n    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n    // to 0xBF.\n    utf8_lower_boundary = 0x80;\n    utf8_upper_boundary = 0xBF;\n\n    // 6. Increase utf-8 bytes seen by one and set utf-8 code point\n    // to utf-8 code point + (byte − 0x80) << (6 × (utf-8 bytes\n    // needed − utf-8 bytes seen)).\n    utf8_bytes_seen += 1;\n    utf8_code_point += (bite - 0x80) << (6 * (utf8_bytes_needed - utf8_bytes_seen));\n\n    // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n    // continue.\n    if (utf8_bytes_seen !== utf8_bytes_needed)\n      return null;\n\n    // 8. Let code point be utf-8 code point.\n    var code_point = utf8_code_point;\n\n    // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n    // seen to 0.\n    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n    // 10. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished;\n\n    // 2. If code point is in the range U+0000 to U+007F, return a\n    // byte whose value is code point.\n    if (inRange(code_point, 0x0000, 0x007f))\n      return code_point;\n\n    // 3. Set count and offset based on the range code point is in:\n    var count, offset;\n    // U+0080 to U+07FF:    1 and 0xC0\n    if (inRange(code_point, 0x0080, 0x07FF)) {\n      count = 1;\n      offset = 0xC0;\n    }\n    // U+0800 to U+FFFF:    2 and 0xE0\n    else if (inRange(code_point, 0x0800, 0xFFFF)) {\n      count = 2;\n      offset = 0xE0;\n    }\n    // U+10000 to U+10FFFF: 3 and 0xF0\n    else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n      count = 3;\n      offset = 0xF0;\n    }\n\n    // 4.Let bytes be a byte sequence whose first byte is (code\n    // point >> (6 × count)) + offset.\n    var bytes = [(code_point >> (6 * count)) + offset];\n\n    // 5. Run these substeps while count is greater than 0:\n    while (count > 0) {\n\n      // 1. Set temp to code point >> (6 × (count − 1)).\n      var temp = code_point >> (6 * (count - 1));\n\n      // 2. Append to bytes 0x80 | (temp & 0x3F).\n      bytes.push(0x80 | (temp & 0x3F));\n\n      // 3. Decrease count by one.\n      count -= 1;\n    }\n\n    // 6. Return bytes bytes, in order.\n    return bytes;\n  };\n}\n\n\n\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/Users/songxu/Develop/test/transform/node_modules/json_typegen_wasm/json_typegen_wasm_bg.js","/Users/songxu/Develop/test/transform/node_modules/json_typegen_wasm/json_typegen_wasm.js","/Users/songxu/Develop/test/transform/node_modules/text-encoding-utf-8/lib/encoding.lib.mjs"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAoD;;AAEpD;;AAEA;AACA;AACA,yEAAyE,yEAAW;AACpF,8CAA8C,yEAAW;AACzD;AACA;AACA;;AAEA;;AAEA;;AAEA,IAAI,KAAU;AACd,yBAAyB,mBAAO,CAAC,MAAqB;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,UAAU,cAAc;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yEAAyE,yEAAW;AACpF,8CAA8C,yEAAW;AACzD;AACA;AACA;;AAEA;;AAEA,mDAAmD,+BAA+B;;AAElF;;AAEA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,YAAY;AACZ;AACO;AACP;AACA,uBAAuB,kGAAoC;AAC3D,2CAA2C,oFAAsB,EAAE,qFAAuB;AAC1F;AACA,4CAA4C,oFAAsB,EAAE,qFAAuB;AAC3F;AACA,8CAA8C,oFAAsB,EAAE,qFAAuB;AAC7F;AACA,QAAQ,sEAAQ;AAChB;AACA;AACA;AACA,KAAK;AACL,QAAQ,kGAAoC;AAC5C,QAAQ,kFAAoB;AAC5B;AACA;;;;;;;;;;;ACjHA;AAAA;AAAA;AAAA;AAAoD;;;;;;;;;ACApD;AAAA;AAAA;AAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,YAAY,gBAAgB;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,gBAAgB;AAC3B,YAAY,OAAO;AACnB;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,yBAAyB;AACvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,QAAQ;AAC9B;AACA,sBAAsB,QAAQ;AAC9B;AACA,sBAAsB,SAAS;AAC/B;AACA,sBAAsB,QAAQ;AAC9B;AACA,sBAAsB,QAAQ;AAC9B;;AAEA,2CAA2C,eAAe;AAC1D,wCAAwC,mBAAmB;AAC3D,4CAA4C,uBAAuB;AACnE;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,QAAQ;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;;AAEA;;AAEA;;AAEA,eAAe,0BAA0B;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,QAAQ;AAC9B;AACA,sBAAsB,SAAS;AAC/B;AACA,uBAAuB,gBAAgB;AACvC,mBAAmB;;AAEnB,2CAA2C,eAAe;AAC1D;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc,WAAW;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gBAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gBAAgB;AAChB,YAAY,gBAAgB;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;;AAExB;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,yBAAyB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEkC","file":"x","sourcesContent":["import * as wasm from './json_typegen_wasm_bg.wasm';\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nif (IN_BROWSER && !window.TextEncoder) {\n        const encoding = require(\"text-encoding-utf-8\");\n        window.TextEncoder = encoding.TextEncoder;\n        window.TextDecoder = encoding.TextDecoder;\n    }\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @param {string} name\n* @param {string} input\n* @param {string} options\n* @returns {string}\n*/\nexport function run(name, input, options) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = passStringToWasm0(options, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        wasm.run(retptr, ptr0, len0, ptr1, len1, ptr2, len2);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\n","import * as wasm from \"./json_typegen_wasm_bg.wasm\";\nexport * from \"./json_typegen_wasm_bg.js\";","'use strict';\n\n// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n//\n// Utilities\n//\n\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n/**\n * @param {*} o\n * @return {Object}\n */\nfunction ToDictionary(o) {\n  if (o === undefined) return {};\n  if (o === Object(o)) return o;\n  throw TypeError('Could not convert argument to dictionary');\n}\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nfunction stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string);\n\n  // 2. Let n be the length of S.\n  var n = s.length;\n\n  // 3. Initialize i to 0.\n  var i = 0;\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = [];\n\n  // 5. While i < n:\n  while (i < n) {\n\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i);\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xD800 || c > 0xDFFF) {\n      // Append to U the Unicode character with code point c.\n      u.push(c);\n    }\n\n    // 0xDC00 ≤ c ≤ 0xDFFF\n    else if (0xDC00 <= c && c <= 0xDFFF) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xFFFD);\n    }\n\n    // 0xD800 ≤ c ≤ 0xDBFF\n    else if (0xD800 <= c && c <= 0xDBFF) {\n      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xFFFD);\n      }\n      // 2. Otherwise, i < n−1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = string.charCodeAt(i + 1);\n\n        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n        if (0xDC00 <= d && d <= 0xDFFF) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3FF;\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3FF;\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b);\n\n          // 4. Set i to i+1.\n          i += 1;\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else  {\n          u.push(0xFFFD);\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1;\n  }\n\n  // 6. Return U.\n  return u;\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nfunction codePointsToString(code_points) {\n  var s = '';\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i];\n    if (cp <= 0xFFFF) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xD800,\n                               (cp & 0x3FF) + 0xDC00);\n    }\n  }\n  return s;\n}\n\n\n//\n// Implementation of Encoding specification\n// https://encoding.spec.whatwg.org/\n//\n\n//\n// 3. Terminology\n//\n\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n * @const\n */ var end_of_stream = -1;\n\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the\n * stream.\n */\nfunction Stream(tokens) {\n  /** @type {!Array.<number>} */\n  this.tokens = [].slice.call(tokens);\n}\n\nStream.prototype = {\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream: function() {\n    return !this.tokens.length;\n  },\n\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n   read: function() {\n    if (!this.tokens.length)\n      return end_of_stream;\n     return this.tokens.shift();\n   },\n\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.\n   */\n  prepend: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.unshift(tokens.pop());\n    } else {\n      this.tokens.unshift(token);\n    }\n  },\n\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.\n   */\n  push: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.push(tokens.shift());\n    } else {\n      this.tokens.push(token);\n    }\n  }\n};\n\n//\n// 4. Encodings\n//\n\n// 4.1 Encoders and decoders\n\n/** @const */\nvar finished = -1;\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return {number} The code point to insert on a decoding error.\n */\nfunction decoderError(fatal, opt_code_point) {\n  if (fatal)\n    throw TypeError('Decoder error');\n  return opt_code_point || 0xFFFD;\n}\n\n/** @interface */\nfunction Decoder() {}\nDecoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point, or |finished|.\n   */\n  handler: function(stream, bite) {}\n};\n\n/** @interface */\nfunction Encoder() {}\nEncoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of code points being encoded.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n   */\n  handler: function(stream, code_point) {}\n};\n\n//\n// 7. API\n//\n\n/** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n// 7.1 Interface TextDecoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextDecoder(encoding, options) {\n  if (!(this instanceof TextDecoder)) {\n    return new TextDecoder(encoding, options);\n  }\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {boolean} */\n  this._BOMseen = false;\n  /** @private @type {?Decoder} */\n  this._decoder = null;\n  /** @private @type {boolean} */\n  this._fatal = Boolean(options['fatal']);\n  /** @private @type {boolean} */\n  this._ignoreBOM = Boolean(options['ignoreBOM']);\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n  Object.defineProperty(this, 'fatal', {value: this._fatal});\n  Object.defineProperty(this, 'ignoreBOM', {value: this._ignoreBOM});\n}\n\nTextDecoder.prototype = {\n  /**\n   * @param {ArrayBufferView=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  decode: function decode(input, options) {\n    var bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input &&\n               input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n                             input.byteOffset,\n                             input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options);\n\n    if (!this._streaming) {\n      this._decoder = new UTF8Decoder({fatal: this._fatal});\n      this._BOMseen = false;\n    }\n    this._streaming = Boolean(options['stream']);\n\n    var input_stream = new Stream(bytes);\n\n    var code_points = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n\n    while (!input_stream.endOfStream()) {\n      result = this._decoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (result === null)\n        continue;\n      if (Array.isArray(result))\n        code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n      else\n        code_points.push(result);\n    }\n    if (!this._streaming) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (result === null)\n          continue;\n        if (Array.isArray(result))\n          code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n        else\n          code_points.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    if (code_points.length) {\n      // If encoding is one of utf-8, utf-16be, and utf-16le, and\n      // ignore BOM flag and BOM seen flag are unset, run these\n      // subsubsteps:\n      if (['utf-8'].indexOf(this.encoding) !== -1 &&\n          !this._ignoreBOM && !this._BOMseen) {\n        // If token is U+FEFF, set BOM seen flag.\n        if (code_points[0] === 0xFEFF) {\n          this._BOMseen = true;\n          code_points.shift();\n        } else {\n          // Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to output.\n          this._BOMseen = true;\n        }\n      }\n    }\n\n    return codePointsToString(code_points);\n  }\n};\n\n// 7.2 Interface TextEncoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextEncoder(encoding, options) {\n  if (!(this instanceof TextEncoder))\n    return new TextEncoder(encoding, options);\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {?Encoder} */\n  this._encoder = null;\n  /** @private @type {{fatal: boolean}} */\n  this._options = {fatal: Boolean(options['fatal'])};\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n}\n\nTextEncoder.prototype = {\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  encode: function encode(opt_string, options) {\n    opt_string = opt_string ? String(opt_string) : '';\n    options = ToDictionary(options);\n\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,\n    // so streaming is not necessary.\n    if (!this._streaming)\n      this._encoder = new UTF8Encoder(this._options);\n    this._streaming = Boolean(options['stream']);\n\n    var bytes = [];\n    var input_stream = new Stream(stringToCodePoints(opt_string));\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n    while (!input_stream.endOfStream()) {\n      result = this._encoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (Array.isArray(result))\n        bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n      else\n        bytes.push(result);\n    }\n    if (!this._streaming) {\n      while (true) {\n        result = this._encoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (Array.isArray(result))\n          bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n        else\n          bytes.push(result);\n      }\n      this._encoder = null;\n    }\n    return new Uint8Array(bytes);\n  }\n};\n\n//\n// 8. The encoding\n//\n\n// 8.1 utf-8\n\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Decoder(options) {\n  var fatal = options.fatal;\n\n  // utf-8's decoder's has an associated utf-8 code point, utf-8\n  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n  // lower boundary (initially 0x80), and a utf-8 upper boundary\n  // (initially 0xBF).\n  var /** @type {number} */ utf8_code_point = 0,\n      /** @type {number} */ utf8_bytes_seen = 0,\n      /** @type {number} */ utf8_bytes_needed = 0,\n      /** @type {number} */ utf8_lower_boundary = 0x80,\n      /** @type {number} */ utf8_upper_boundary = 0xBF;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n    // set utf-8 bytes needed to 0 and return error.\n    if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n      utf8_bytes_needed = 0;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream)\n      return finished;\n\n    // 3. If utf-8 bytes needed is 0, based on byte:\n    if (utf8_bytes_needed === 0) {\n\n      // 0x00 to 0x7F\n      if (inRange(bite, 0x00, 0x7F)) {\n        // Return a code point whose value is byte.\n        return bite;\n      }\n\n      // 0xC2 to 0xDF\n      if (inRange(bite, 0xC2, 0xDF)) {\n        // Set utf-8 bytes needed to 1 and utf-8 code point to byte\n        // − 0xC0.\n        utf8_bytes_needed = 1;\n        utf8_code_point = bite - 0xC0;\n      }\n\n      // 0xE0 to 0xEF\n      else if (inRange(bite, 0xE0, 0xEF)) {\n        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (bite === 0xE0)\n          utf8_lower_boundary = 0xA0;\n        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (bite === 0xED)\n          utf8_upper_boundary = 0x9F;\n        // 3. Set utf-8 bytes needed to 2 and utf-8 code point to\n        // byte − 0xE0.\n        utf8_bytes_needed = 2;\n        utf8_code_point = bite - 0xE0;\n      }\n\n      // 0xF0 to 0xF4\n      else if (inRange(bite, 0xF0, 0xF4)) {\n        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (bite === 0xF0)\n          utf8_lower_boundary = 0x90;\n        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (bite === 0xF4)\n          utf8_upper_boundary = 0x8F;\n        // 3. Set utf-8 bytes needed to 3 and utf-8 code point to\n        // byte − 0xF0.\n        utf8_bytes_needed = 3;\n        utf8_code_point = bite - 0xF0;\n      }\n\n      // Otherwise\n      else {\n        // Return error.\n        return decoderError(fatal);\n      }\n\n      // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code\n      // point to utf-8 code point << (6 × utf-8 bytes needed) and\n      // return continue.\n      utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);\n      return null;\n    }\n\n    // 4. If byte is not in the range utf-8 lower boundary to utf-8\n    // upper boundary, run these substeps:\n    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n\n      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n      // utf-8 upper boundary to 0xBF.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite);\n\n      // 3. Return error.\n      return decoderError(fatal);\n    }\n\n    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n    // to 0xBF.\n    utf8_lower_boundary = 0x80;\n    utf8_upper_boundary = 0xBF;\n\n    // 6. Increase utf-8 bytes seen by one and set utf-8 code point\n    // to utf-8 code point + (byte − 0x80) << (6 × (utf-8 bytes\n    // needed − utf-8 bytes seen)).\n    utf8_bytes_seen += 1;\n    utf8_code_point += (bite - 0x80) << (6 * (utf8_bytes_needed - utf8_bytes_seen));\n\n    // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n    // continue.\n    if (utf8_bytes_seen !== utf8_bytes_needed)\n      return null;\n\n    // 8. Let code point be utf-8 code point.\n    var code_point = utf8_code_point;\n\n    // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n    // seen to 0.\n    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n    // 10. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished;\n\n    // 2. If code point is in the range U+0000 to U+007F, return a\n    // byte whose value is code point.\n    if (inRange(code_point, 0x0000, 0x007f))\n      return code_point;\n\n    // 3. Set count and offset based on the range code point is in:\n    var count, offset;\n    // U+0080 to U+07FF:    1 and 0xC0\n    if (inRange(code_point, 0x0080, 0x07FF)) {\n      count = 1;\n      offset = 0xC0;\n    }\n    // U+0800 to U+FFFF:    2 and 0xE0\n    else if (inRange(code_point, 0x0800, 0xFFFF)) {\n      count = 2;\n      offset = 0xE0;\n    }\n    // U+10000 to U+10FFFF: 3 and 0xF0\n    else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n      count = 3;\n      offset = 0xF0;\n    }\n\n    // 4.Let bytes be a byte sequence whose first byte is (code\n    // point >> (6 × count)) + offset.\n    var bytes = [(code_point >> (6 * count)) + offset];\n\n    // 5. Run these substeps while count is greater than 0:\n    while (count > 0) {\n\n      // 1. Set temp to code point >> (6 × (count − 1)).\n      var temp = code_point >> (6 * (count - 1));\n\n      // 2. Append to bytes 0x80 | (temp & 0x3F).\n      bytes.push(0x80 | (temp & 0x3F));\n\n      // 3. Decrease count by one.\n      count -= 1;\n    }\n\n    // 6. Return bytes bytes, in order.\n    return bytes;\n  };\n}\n\nexport {TextEncoder, TextDecoder};\n"]}}